"code","expect"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"let x R:
x + 2 = 5

x = 5 - 2 = 4","True"
"let x R:
x + 2 = 5
x = 5 - 2 = 4","True"
"let x R:
    x + 2 = 5
    x = 5 - 2 = 4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n N, m N","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"fn f(x R) R:
    dom:
        x > 0
    =>:
        f(x) > 0","True"
"fn_template sequence(s set):
    fn (n N) s","True"
"let a sequence(R), b finite_sequence(Z, 10)","True"
"let a sequence(R), b finite_sequence(Z, 10)","True"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let s3, s4 set:
    s3 := {1, 2, 3}
    s4 := {1, 2, 3}

prove_over_finite_set:
    forall x s3, y s4:
        x * y >= 1","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop g(x R)
prop s(x R)
prop q(x R)

know:
    forall x R: $g(x) => $s(x)
    forall x R: $s(x) => $q(x)
    not $q(17)

claim:
    not $g(17)
    prove_by_contradiction:
        $s(17)
        $q(17)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let self_complex set
fn sc(x, y R) self_complex # sc means self_complex
fn sc_add(x, y self_complex) self_complex
fn sc_mul(x, y self_complex) self_complex
fn sc_div(x, y self_complex) self_complex
fn sc_sub(x, y self_complex) self_complex
fn sc_neg(x self_complex) self_complex
fn sc_abs(x self_complex) R
fn sc_conj(x self_complex) self_complex

know:
    forall x, y, a, b R:
    	sc(x, y) \sc_add sc(a, b) = sc(x + a, y + b)
        sc(x, y) \sc_mul sc(a, b) = sc(x * a - y * b, x * b + y * a)
        sc(x, y) \sc_sub sc(a, b) = sc(x - a, y - b)
    forall x, y R:
        sc_neg(sc(x, y)) = sc(-x, -y)
        sc_conj(sc(x, y)) = sc(x, -y)
        sc_abs(sc(x, y)) = (x * x + y * y) ^ (1/2)
    forall x, y, a, b R:
        or:
            a != 0
            b != 0
        =>:
        	sc(x, y) \sc_div sc(a, b) = sc((x * a + y * b) / (a * a + b * b), (y * a - x * b) / (a * a + b * b))
    	
prove:
	sc(1, 2) \sc_add sc(3, 4) = sc(1 + 3, 2 + 4)
    sc(1, 2) \sc_add sc(3, 4) = sc(4, 6)
    sc(1, 2) \sc_mul sc(3, 4) = sc(1 * 3 - 2 * 4, 1 * 4 + 2 * 3)
    sc(1, 2) \sc_mul sc(3, 4) = sc(-5, 10)
    sc(1, 2) \sc_sub sc(3, 4) = sc(1 - 3, 2 - 4)
    sc(1, 2) \sc_sub sc(3, 4) = sc(-2, -2)
    sc_neg(sc(1, 2)) = sc(-1, -2)
    sc_conj(sc(1, 2)) = sc(1, -2)
    sc_abs(sc(1, 2)) = (1 * 1 + 2 * 2) ^ (1/2)
    sc_abs(sc(1, 2)) = 5 ^ (1/2)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"let n N, m N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"# The follow code will output unknown
1 = 2","False"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"let n, m N: n > 0, m > n","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"# definition of a group, and prove R and Z are groups
# 定义一个群，并证明 R 和 Z 是群

prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e
    forall x s:
        mul(x, e) = x
        mul(e, x) = x

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"let weekdays set
prop is_monday(x weekdays)
prop is_tuesday(x weekdays)
prop is_wednesday(x weekdays)
prop is_thursday(x weekdays)
prop is_friday(x weekdays)
prop is_saturday(x weekdays)
prop is_sunday(x weekdays)
know forall x weekdays => or($is_monday(x), $is_tuesday(x), $is_wednesday(x), $is_thursday(x), $is_friday(x), $is_saturday(x), $is_sunday(x))

prop stay_at_home_doctor_wear_his_uniform(x weekdays)
know:
    forall x weekdays: $is_monday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_tuesday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_wednesday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_thursday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_friday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_saturday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_sunday(x) => $stay_at_home_doctor_wear_his_uniform(x)

prop stay_at_home_doctor_always_wear_his_uniform():
    forall x weekdays => $stay_at_home_doctor_wear_his_uniform(x)

claim:
    forall x weekdays => $stay_at_home_doctor_wear_his_uniform(x)
    prove:
        prove_in_each_case:
            or($is_monday(x), $is_tuesday(x), $is_wednesday(x), $is_thursday(x), $is_friday(x), $is_saturday(x), $is_sunday(x))
            =>:
                $stay_at_home_doctor_wear_his_uniform(x)
            prove:
                $is_monday(x)
            prove:
                $is_tuesday(x)
            prove:
                $is_wednesday(x)
            prove:
                $is_thursday(x)
            prove:
                $is_friday(x)
            prove:
                $is_saturday(x)
            prove:
                $is_sunday(x)

$stay_at_home_doctor_always_wear_his_uniform()","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"let s set:
    s := {1, 2, 3}

prove_over_finite_set:
    forall x s:
        x > 0","True"
"have set s := {}

# any factual statement is true on empty set
prove_over_finite_set:
    forall x s:
        x > 0
        x < 0","True"
"let s3, s4 set:
    s3 := {1, 2, 3}
    s4 := {1, 2, 3}

prove_over_finite_set:
    forall x s3, y s4:
        x * y >= 1","True"
"# definition of a group, and prove R and Z are groups
# 定义一个群，并证明 R 和 Z 是群

prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e
    forall x s:
        mul(x, e) = x
        mul(e, x) = x

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"# The follow code will output unknown
1 = 2","False"
"# The follow code will output error
1","False"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let n, m N:
    n > 0
    m > n","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have x R, y R","True"
"let x R, y R","True"
"let x R, y R
x $in N
y $in N","True"
"let x R, y R
x in N
y in N","False"
"let x R, y R
x $in N","True"
"let x R, y R
x $in R","True"
"let x R, y R
x $in R","True"
"let x R, y R
x $in N","True"
"let x N, y R
x $in R","True"
"let x N, y R
x $in R
y $in R","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
4 * x + 6 * y = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
4 * x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6

2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6

2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"1 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Welcome to Litex Playground!
let h = 8","False"
"# Welcome to Litex Playground!
let h: 8","False"
"# Welcome to Litex Playground!
let h Z
(8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z
x = (8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z
    x = (8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z:
    x = (8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z, n R:
    x = (8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z, x R:
    x = (8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z
have x
x = (8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z
let x R
x = (8h + (h+8)%9 - 17)/9","False"
"# Welcome to Litex Playground!
let h Z
let x R
x = 8h","False"
"# Welcome to Litex Playground!
let h Z
let x
x = 8 * h","False"
"# Welcome to Litex Playground!
let h Z
let x R
x = 8 * h","True"
"# Welcome to Litex Playground!
let h Z
have x
  x = 8 * h","False"
"# Welcome to Litex Playground!
let h Z
have x:
  x = 8 * h","True"
"# Welcome to Litex Playground!
let h Z:
have x:
  x = 8 * h","True"
"# Welcome to Litex Playground!
let h Z:
  have x:
    x = 8 * h","False"
"# Welcome to Litex Playground!
let h Z:
  x = 8 * h","False"
"# Welcome to Litex Playground!
: let h Z:
  x = 8 * h","False"
"# Welcome to Litex Playground!
let h Z
  x = 8 * h","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n N, m N","True"
"let a N: a = 2, a = 3","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"square_root(4) $in R","False"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"square_root(4) $in R","False"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"square_root(4) $in R","False"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"=:
    1
    2 - 1
    1 * 1","True"
"=(1, 2 - 1, 1 * 1)","False"
"1 + 1 = 2
4 / 2 = 2","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"let n, m N:
    n > 0
    m > n","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!
let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"# Welcome to Litex Playground!
let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 2 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!

x = 1","False"
"# Welcome to Litex Playground!

x = 1;","False"
"let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -5","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n N, m N","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"let n N, m N","True"
"let n N, m N","True"
"let n N, m N","True"
"let n N, m N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"# Welcome to Litex Playground!","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"""""""
Basics
""""""

forall x R, a R, b R:
    a + x = b
    =>:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    =>:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        =>:
            b - a > 0

    forall a R, b R:
        b > a
        =>:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        =>:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    <=>:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know @exist x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    <=>:
        x $in s
        $is_smallest_element_of(x, s)
    
know forall x Z, y Z => x * y $in Z, x + y $in Z, x - y $in Z

know forall x N, y N => x + y $in N, x * y $in N

know forall x N, y N => x + y $in N, x * y $in N


 """"""
Chapter 1
""""""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    let x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        =>:
            b / a $in Q

""""""
Chapter 2
""""""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist q Z st exist_largest_multiple_of(d Z, a Z):
    <=>:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    <=>:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        =>:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        =>:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        =>:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z: d != 0, a $is_divisible_by d, b $is_divisible_by d => gcd(a, b) $is_divisible_by d

""""""
Chapter 3
""""""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know:
    forall a Z, b Z:
        gcd(a, b) = 1
        <=>:
            $exist_relatively_prime(a, b)

# Corollary 3.1
know:
    forall a Z, b Z:
        dom:
            a != 0
            b != 0
        =>:
            a / gcd(a, b) $in Z
            b / gcd(a, b) $in Z
            gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know:
    forall a Z, b Z, d Z:
        a $is_divisible_by d
        b $is_divisible_by d
        =>:
            a + b $is_divisible_by d
            a - b $is_divisible_by d
            a * b $is_divisible_by d

# Theorem 3.2
know:
    forall a Z, b Z, d Z:
        gcd(a, d) = 1
        a*b $is_divisible_by d
        =>:
            b $is_divisible_by d

# Corollary 3.1
know:
    forall a Z, b Z, d Z:
        gcd(a, b) = 1
        gcd(a, d) = 1
        =>:
            gcd(a, b*d) = 1","True"
"""""""
Basics
""""""

forall x R, a R, b R:
    a + x = b
    =>:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    =>:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        =>:
            b - a > 0

    forall a R, b R:
        b > a
        =>:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        =>:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    <=>:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know @exist x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    <=>:
        x $in s
        $is_smallest_element_of(x, s)
    
know forall x Z, y Z => x * y $in Z, x + y $in Z, x - y $in Z

know forall x N, y N => x + y $in N, x * y $in N

know forall x N, y N => x + y $in N, x * y $in N


 """"""
Chapter 1
""""""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    let x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        =>:
            b / a $in Q

""""""
Chapter 2
""""""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist q Z st exist_largest_multiple_of(d Z, a Z):
    <=>:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    <=>:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        =>:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        =>:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        =>:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z: d != 0, a $is_divisible_by d, b $is_divisible_by d => gcd(a, b) $is_divisible_by d

""""""
Chapter 3
""""""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know:
    forall a Z, b Z:
        gcd(a, b) = 1
        <=>:
            $exist_relatively_prime(a, b)

# Corollary 3.1
know:
    forall a Z, b Z:
        dom:
            a != 0
            b != 0
        =>:
            a / gcd(a, b) $in Z
            b / gcd(a, b) $in Z
            gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know:
    forall a Z, b Z, d Z:
        a $is_divisible_by d
        b $is_divisible_by d
        =>:
            a + b $is_divisible_by d
            a - b $is_divisible_by d
            a * b $is_divisible_by d

# Theorem 3.2
know:
    forall a Z, b Z, d Z:
        gcd(a, d) = 1
        a*b $is_divisible_by d
        =>:
            b $is_divisible_by d

# Corollary 3.1
know:
    forall a Z, b Z, d Z:
        gcd(a, b) = 1
        gcd(a, d) = 1
        =>:
            gcd(a, b*d) = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"""""""
Basics
""""""

forall x R, a R, b R:
    a + x = b
    =>:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    =>:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        =>:
            b - a > 0

    forall a R, b R:
        b > a
        =>:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        =>:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    <=>:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know @exist x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    <=>:
        x $in s
        $is_smallest_element_of(x, s)
    
know forall x Z, y Z => x * y $in Z, x + y $in Z, x - y $in Z

know forall x N, y N => x + y $in N, x * y $in N

know forall x N, y N => x + y $in N, x * y $in N


 """"""
Chapter 1
""""""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    let x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        =>:
            b / a $in Q

""""""
Chapter 2
""""""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist q Z st exist_largest_multiple_of(d Z, a Z):
    <=>:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    <=>:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        =>:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        =>:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        =>:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z: d != 0, a $is_divisible_by d, b $is_divisible_by d => gcd(a, b) $is_divisible_by d

""""""
Chapter 3
""""""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know:
    forall a Z, b Z:
        gcd(a, b) = 1
        <=>:
            $exist_relatively_prime(a, b)

# Corollary 3.1
know:
    forall a Z, b Z:
        dom:
            a != 0
            b != 0
        =>:
            a / gcd(a, b) $in Z
            b / gcd(a, b) $in Z
            gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know:
    forall a Z, b Z, d Z:
        a $is_divisible_by d
        b $is_divisible_by d
        =>:
            a + b $is_divisible_by d
            a - b $is_divisible_by d
            a * b $is_divisible_by d

# Theorem 3.2
know:
    forall a Z, b Z, d Z:
        gcd(a, d) = 1
        a*b $is_divisible_by d
        =>:
            b $is_divisible_by d

# Corollary 3.1
know:
    forall a Z, b Z, d Z:
        gcd(a, b) = 1
        gcd(a, d) = 1
        =>:
            gcd(a, b*d) = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"forall x N_pos:
    =>:
        x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"prop g(x R)
prop s(x R)
prop q(x R)

know:
    forall x R: $g(x) => $s(x)
    forall x R: $s(x) => $q(x)

claim:
    forall x R: $g(x) => $q(x)
    prove:
        $s(x)
        $q(x)","True"
"claim:
    @p(x N):
        x > 1
        =>:
            x > -1
    prove:
        $larger_is_transitive(x, 1, -1)
        x > -1

let a N:
    a > 1
$p(a)
a > -1","True"
"prop g(x R)
prop s(x R)
prop q(x R)

know:
    forall x R: $g(x) => $s(x)
    forall x R: $s(x) => $q(x)
    not $q(17)

claim:
    not $g(17)
    prove_by_contradiction:
        $s(17)
        $q(17)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"fn f(x R) R:
    dom:
        x > 0
    =>:
        f(x) > 0","True"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"2 $in N","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"let x R: x > 0","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"have a R
know a = 1
a = 1","True"
"have a R
know a = 1
a = 1","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14","True"
"let x N, y N:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14","True"
"let x N, y N:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

x = 4","True"
"let x R, y R:
    x = y
    y = 5","True"
"let x R, y R:
    x = y
    y = 5


x = 5","True"
"let x R, y R:
    x = y + 5
    y = 5

x = 10","True"
"let x R, y R:
    x = y + 5
    y = 5


x = 10","True"
"let x R, y R:
    y = 5
    x = y + 5

x = 10","True"
"let x R, y R:
    y = 5
    x = (y + 5)

x = 10","True"
"let x R, y R:
    y = 5
    x = (y + 5)

x = y + 5","True"
"let x R, y R:
    y = 5
    x = (y + 5)

x = 10","True"
"let x R, y R:
    y = 5
    x = (y + 5)

x = 10","True"
"let x R, y R:
    y = 5
    x = (y + 5)

x = 10","True"
"let x R, y R:
    y = 5
    x = (y + 5)

x = 20 - 10","True"
"let x R, y R:
    y = 5
    x = (y + 5)

x = 2*y","True"
"let x R, y R:
    y = 5
    x = (y + 5)

y = x / 2","True"
"let x R, y R:
    y = 5
    x = y * 2","True"
"let x R, y R:
    y = 5
    x = y * 2

y = x / y","True"
"let x R, y R:
    y = 5
    x = y * 2

y = x / 2","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have Term nonempty_set
have I, S, K, C_, B, U Term
fn app(a Term, b Term) Term

# I = Lambda x.x
# S = lambda xyz.(xz)(yz)
# K = lambda xy.x
# C_ = lambda xyz.xzy
# B = lambda xyz.x(yz)
# U = lambda x.xx

have Value nonempty_set
have I0, K0, S0, C0, B0, U0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value
fn C1(a Term) Value
fn C2(a Term, b Term) Value
fn B1(a Term) Value
fn B2(a Term, b Term) Value
fn U1(a Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

know:
    # M0 steps down
    forall x, y Term, l List:
        M0(app(x, y), l) = M0(x, Cons(y, l))
    forall l List:
        M0(I, l) = M1(I0, l)
        M0(K, l) = M1(K0, l)
        M0(S, l) = M1(S0, l)
        M0(C_, l) = M1(C0, l)
        M0(B, l) = M1(B0, l)
        M0(U, l) = M1(U0, l)

    # M1 perform the combinators' actions
    M1(I0, Nil) = M2(I0)
    M1(K0, Nil) = M2(K0)
    M1(S0, Nil) = M2(S0)
    M1(C0, Nil) = M2(C0)
    M1(B0, Nil) = M2(B0)
    M1(U0, Nil) = M2(U0)
    forall x Term, l List:
        M1(I0, Cons(x, l)) = M0(x, l)
        M1(U0, Cons(x, l)) = M0(app(x, x), l)
        M1(K0, Cons(x, l)) = M1(K1(x), l)
        M1(S0, Cons(x, l)) = M1(S1(x), l)
        M1(C0, Cons(x, l)) = M1(C1(x), l)
        M1(B0, Cons(x, l)) = M1(B1(x), l)
        M1(K0(x), Nil) = M2(K0(x))
        M1(S1(x), Nil) = M2(S1(x))
        M1(C1(x), Nil) = M2(C1(x))
        M1(B1(x), Nil) = M2(B1(x))
    forall x, y Term, l List:
        M1(K0(x), Cons(y, l)) = M0(x, l)
        M1(S1(x), Cons(y, l)) = M1(S2(x, y), l)
        M1(C1(x), Cons(y, l)) = M1(C2(x, y), l)
        M1(B1(x), Cons(y, l)) = M1(B2(x, y), l)
        M1(S2(x, y), Nil) = M2(S2(x, y))
        M1(C2(x, y), Nil) = M2(C2(x, y))
        M1(B2(x, y), Nil) = M2(B2(x, y))
    forall x, y, z Term, l List:
        M1(S2(x, y), Cons(z, l)) = M0(app(app(x, z), app(y, z)), l)
        M1(C2(x, y), Cons(z, l)) = M0(app(app(x, z), y), l)
        M1(B2(x, y), Cons(z, l)) = M0(app(x, app(y, z)), l)

have Y Term
know:
    Y = app(app(B, U), app(app(C_, B), U))

have F Term

have program Term
know:
    program = app(Y, F)

# Hereby we noticed that ""step"" and ""evalm"" are only symbols that require transitivity
# Thus we use ""="" to simplify the program
# You can expand it to ""step"" and ""evalm"" if you want

know forall a, b Term: M0(a, Nil) = M0(b, Nil) => a = b
=:
    M0(program, Nil)
    M0(app(Y, F), Nil)
    M0(app(app(app(B, U), app(app(C_, B), U)), F), Nil)
    M0(app(app(B, U), app(app(C_, B), U)), Cons(F, Nil))
    M0(app(B, U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M0(B, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B0, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B1(U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M1(B2(U, app(app(C_, B), U)), Cons(F, Nil))
    M0(app(U, app(app(app(C_, B), U), F)), Nil)
    M0(U, Cons(app(app(app(C_, B), U), F), Nil))
    M1(U0, Cons(app(app(app(C_, B), U), F), Nil))
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)

=:
    M0(app(app(app(C_, B), U), F), Nil)
    M0(app(app(C_, B), U), Cons(F, Nil))
    M0(app(C_, B), Cons(U, Cons(F, Nil)))
    M0(C_, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C0, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C1(B), Cons(U, Cons(F, Nil)))
    M1(C2(B, U), Cons(F, Nil))
    M0(app(app(B, F), U), Nil)

app(app(app(C_, B), U), F) = app(app(B, F), U)

=:
    M0(program, Nil)
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(app(app(B, F), U), Cons(app(app(B, F), U), Nil))
    M0(app(B, F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M0(B, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B0, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B1(F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M1(B2(F, U), Cons(app(app(B, F), U), Nil))
    M0(app(F, app(U, app(app(B, F), U))), Nil)

=:
    M0(app(U, app(app(B, F), U)), Nil)
    M0(U, Cons(app(app(B, F), U), Nil))
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(program, Nil)

app(U, app(app(B, F), U)) = program

=:
    M0(program, Nil)
    M0(app(F, app(U, app(app(B, F), U))), Nil)
    M0(app(F, program), Nil)

program = app(F, program)
app(Y, F) = app(F, app(Y, F))

# Thus, we've proved the property of Y-combinator
# Y F = F(Y F)","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"know forall a, b, c R: a < b, b < c => a < c
let a, b, c R: a < b, b < c
# a < c # This does not work!","True"
"prop transitivity_of_less(a, b, c R):
    a < b
    b < c
    <=>:
        a < c
know forall a, b, c R: a < b, b < c => $transitivity_of_less(a, b, c)

let a, b, c R: a < b, b < c
$transitivity_of_less(a, b, c)
a < c","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"have a N, b Q, c R
let e N, f Q, g R","True"
"have a N
a $in N","True"
"have a N
a $in N","True"
"fn_template self_defined_seq(s set):
    fn (n N) s

fn f(n N) R

f $in self_defined_seq(R)","True"
"1 + 1 = 2
2 * (1 + 1) = 3 + 1
have x, y, z R
(x + 1) ^ 2 = x ^ 2 + 2 * x + 1
(x + y) * (x + z) = x ^ 2 + x * y + x * z + y * z
x + z = z + x","True"
"have fn:
    a(x R) R:
        x > 0
        =>:
            a(x) > 0
    prove:
        x > 0
    have x","True"
"have fn g(x R) R = x
have fn s(x R) R = x^2
have fn q(x R) R = x^2 + 1","True"
"fn_template sequence_of_real_numbers():
    fn (n N) R","True"
"let x R: x = 1

or:
    x = 1
    x = 2

or(x = 1, x = 2)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"forall x R: x = 1 => not x = 2 <=> x != 2","True"
"fn_template sequence(s set):
    fn (n N) s","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x N, y N:
    x = y
    x > 0

y > 0","True"
"have x N
x = x
x + 2 = x + 2","True"
"let a, b, c R:
    a = b
    b = c

a = c","True"
"let a, b, c, d, e R:
    (a + 2) * d * e = a
    a = c

(a + 2) * d * e = c","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let n N, m N","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"or(1 = 1, 1 = 2)","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have Term nonempty_set
have I, S, K, C_, B, U Term
fn app(a Term, b Term) Term

# I = Lambda x.x
# S = lambda xyz.(xz)(yz)
# K = lambda xy.x
# C_ = lambda xyz.xzy
# B = lambda xyz.x(yz)
# U = lambda x.xx

have Value nonempty_set
have I0, K0, S0, C0, B0, U0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value
fn C1(a Term) Value
fn C2(a Term, b Term) Value
fn B1(a Term) Value
fn B2(a Term, b Term) Value
fn U1(a Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

know:
    # M0 steps down
    forall x, y Term, l List:
        M0(app(x, y), l) = M0(x, Cons(y, l))
    forall l List:
        M0(I, l) = M1(I0, l)
        M0(K, l) = M1(K0, l)
        M0(S, l) = M1(S0, l)
        M0(C_, l) = M1(C0, l)
        M0(B, l) = M1(B0, l)
        M0(U, l) = M1(U0, l)

    # M1 perform the combinators' actions
    M1(I0, Nil) = M2(I0)
    M1(K0, Nil) = M2(K0)
    M1(S0, Nil) = M2(S0)
    M1(C0, Nil) = M2(C0)
    M1(B0, Nil) = M2(B0)
    M1(U0, Nil) = M2(U0)
    forall x Term, l List:
        M1(I0, Cons(x, l)) = M0(x, l)
        M1(U0, Cons(x, l)) = M0(app(x, x), l)
        M1(K0, Cons(x, l)) = M1(K1(x), l)
        M1(S0, Cons(x, l)) = M1(S1(x), l)
        M1(C0, Cons(x, l)) = M1(C1(x), l)
        M1(B0, Cons(x, l)) = M1(B1(x), l)
        M1(K0(x), Nil) = M2(K0(x))
        M1(S1(x), Nil) = M2(S1(x))
        M1(C1(x), Nil) = M2(C1(x))
        M1(B1(x), Nil) = M2(B1(x))
    forall x, y Term, l List:
        M1(K0(x), Cons(y, l)) = M0(x, l)
        M1(S1(x), Cons(y, l)) = M1(S2(x, y), l)
        M1(C1(x), Cons(y, l)) = M1(C2(x, y), l)
        M1(B1(x), Cons(y, l)) = M1(B2(x, y), l)
        M1(S2(x, y), Nil) = M2(S2(x, y))
        M1(C2(x, y), Nil) = M2(C2(x, y))
        M1(B2(x, y), Nil) = M2(B2(x, y))
    forall x, y, z Term, l List:
        M1(S2(x, y), Cons(z, l)) = M0(app(app(x, z), app(y, z)), l)
        M1(C2(x, y), Cons(z, l)) = M0(app(app(x, z), y), l)
        M1(B2(x, y), Cons(z, l)) = M0(app(x, app(y, z)), l)

have Y Term
know:
    Y = app(app(B, U), app(app(C_, B), U))

have F Term

have program Term
know:
    program = app(Y, F)

# Hereby we noticed that ""step"" and ""evalm"" are only symbols that require transitivity
# Thus we use ""="" to simplify the program
# You can expand it to ""step"" and ""evalm"" if you want

know forall a, b Term: M0(a, Nil) = M0(b, Nil) => a = b
=:
    M0(program, Nil)
    M0(app(Y, F), Nil)
    M0(app(app(app(B, U), app(app(C_, B), U)), F), Nil)
    M0(app(app(B, U), app(app(C_, B), U)), Cons(F, Nil))
    M0(app(B, U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M0(B, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B0, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B1(U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M1(B2(U, app(app(C_, B), U)), Cons(F, Nil))
    M0(app(U, app(app(app(C_, B), U), F)), Nil)
    M0(U, Cons(app(app(app(C_, B), U), F), Nil))
    M1(U0, Cons(app(app(app(C_, B), U), F), Nil))
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)

=:
    M0(app(app(app(C_, B), U), F), Nil)
    M0(app(app(C_, B), U), Cons(F, Nil))
    M0(app(C_, B), Cons(U, Cons(F, Nil)))
    M0(C_, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C0, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C1(B), Cons(U, Cons(F, Nil)))
    M1(C2(B, U), Cons(F, Nil))
    M0(app(app(B, F), U), Nil)

app(app(app(C_, B), U), F) = app(app(B, F), U)

=:
    M0(program, Nil)
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(app(app(B, F), U), Cons(app(app(B, F), U), Nil))
    M0(app(B, F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M0(B, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B0, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B1(F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M1(B2(F, U), Cons(app(app(B, F), U), Nil))
    M0(app(F, app(U, app(app(B, F), U))), Nil)

=:
    M0(app(U, app(app(B, F), U)), Nil)
    M0(U, Cons(app(app(B, F), U), Nil))
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(program, Nil)

app(U, app(app(B, F), U)) = program

=:
    M0(program, Nil)
    M0(app(F, app(U, app(app(B, F), U))), Nil)
    M0(app(F, program), Nil)

program = app(F, program)
app(Y, F) = app(F, app(Y, F))

# Thus, we've proved the property of Y-combinator
# Y F = F(Y F)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N
a $in N","True"
"have a N
N $in N","True"
"prop g(x R)
prop s(x R)
prop q(x R)

know:
    forall x R: $g(x) => $s(x)
    forall x R: $s(x) => $q(x)
    not $q(17)

claim:
    not $g(17)
    prove_by_contradiction:
        $s(17)
        $q(17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have Term nonempty_set
have I, S, K, C_, B, U Term
fn app(a Term, b Term) Term

# I = Lambda x.x
# S = lambda xyz.(xz)(yz)
# K = lambda xy.x
# C_ = lambda xyz.xzy
# B = lambda xyz.x(yz)
# U = lambda x.xx

have Value nonempty_set
have I0, K0, S0, C0, B0, U0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value
fn C1(a Term) Value
fn C2(a Term, b Term) Value
fn B1(a Term) Value
fn B2(a Term, b Term) Value
fn U1(a Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

know:
    # M0 steps down
    forall x, y Term, l List:
        M0(app(x, y), l) = M0(x, Cons(y, l))
    forall l List:
        M0(I, l) = M1(I0, l)
        M0(K, l) = M1(K0, l)
        M0(S, l) = M1(S0, l)
        M0(C_, l) = M1(C0, l)
        M0(B, l) = M1(B0, l)
        M0(U, l) = M1(U0, l)

    # M1 perform the combinators' actions
    M1(I0, Nil) = M2(I0)
    M1(K0, Nil) = M2(K0)
    M1(S0, Nil) = M2(S0)
    M1(C0, Nil) = M2(C0)
    M1(B0, Nil) = M2(B0)
    M1(U0, Nil) = M2(U0)
    forall x Term, l List:
        M1(I0, Cons(x, l)) = M0(x, l)
        M1(U0, Cons(x, l)) = M0(app(x, x), l)
        M1(K0, Cons(x, l)) = M1(K1(x), l)
        M1(S0, Cons(x, l)) = M1(S1(x), l)
        M1(C0, Cons(x, l)) = M1(C1(x), l)
        M1(B0, Cons(x, l)) = M1(B1(x), l)
        M1(K0(x), Nil) = M2(K0(x))
        M1(S1(x), Nil) = M2(S1(x))
        M1(C1(x), Nil) = M2(C1(x))
        M1(B1(x), Nil) = M2(B1(x))
    forall x, y Term, l List:
        M1(K0(x), Cons(y, l)) = M0(x, l)
        M1(S1(x), Cons(y, l)) = M1(S2(x, y), l)
        M1(C1(x), Cons(y, l)) = M1(C2(x, y), l)
        M1(B1(x), Cons(y, l)) = M1(B2(x, y), l)
        M1(S2(x, y), Nil) = M2(S2(x, y))
        M1(C2(x, y), Nil) = M2(C2(x, y))
        M1(B2(x, y), Nil) = M2(B2(x, y))
    forall x, y, z Term, l List:
        M1(S2(x, y), Cons(z, l)) = M0(app(app(x, z), app(y, z)), l)
        M1(C2(x, y), Cons(z, l)) = M0(app(app(x, z), y), l)
        M1(B2(x, y), Cons(z, l)) = M0(app(x, app(y, z)), l)

have Y Term
know:
    Y = app(app(B, U), app(app(C_, B), U))

have F Term

have program Term
know:
    program = app(Y, F)

# Hereby we noticed that ""step"" and ""evalm"" are only symbols that require transitivity
# Thus we use ""="" to simplify the program
# You can expand it to ""step"" and ""evalm"" if you want

know forall a, b Term: M0(a, Nil) = M0(b, Nil) => a = b
=:
    M0(program, Nil)
    M0(app(Y, F), Nil)
    M0(app(app(app(B, U), app(app(C_, B), U)), F), Nil)
    M0(app(app(B, U), app(app(C_, B), U)), Cons(F, Nil))
    M0(app(B, U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M0(B, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B0, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B1(U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M1(B2(U, app(app(C_, B), U)), Cons(F, Nil))
    M0(app(U, app(app(app(C_, B), U), F)), Nil)
    M0(U, Cons(app(app(app(C_, B), U), F), Nil))
    M1(U0, Cons(app(app(app(C_, B), U), F), Nil))
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)

=:
    M0(app(app(app(C_, B), U), F), Nil)
    M0(app(app(C_, B), U), Cons(F, Nil))
    M0(app(C_, B), Cons(U, Cons(F, Nil)))
    M0(C_, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C0, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C1(B), Cons(U, Cons(F, Nil)))
    M1(C2(B, U), Cons(F, Nil))
    M0(app(app(B, F), U), Nil)

app(app(app(C_, B), U), F) = app(app(B, F), U)

=:
    M0(program, Nil)
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(app(app(B, F), U), Cons(app(app(B, F), U), Nil))
    M0(app(B, F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M0(B, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B0, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B1(F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M1(B2(F, U), Cons(app(app(B, F), U), Nil))
    M0(app(F, app(U, app(app(B, F), U))), Nil)

=:
    M0(app(U, app(app(B, F), U)), Nil)
    M0(U, Cons(app(app(B, F), U), Nil))
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(program, Nil)

app(U, app(app(B, F), U)) = program

=:
    M0(program, Nil)
    M0(app(F, app(U, app(app(B, F), U))), Nil)
    M0(app(F, program), Nil)

program = app(F, program)
app(Y, F) = app(F, app(Y, F))

# Thus, we've proved the property of Y-combinator
# Y F = F(Y F)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Welcome to Litex Playground!
1 + 2","False"
"# Welcome to Litex Playground!
1 + 2 = 5","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"let n N, m N","True"
"have a N, b Q, c R, q C","True"
"prop p(x R)","True"
"prop p(x R)","True"
"prop p(x R)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"forall x N_pos => x $in N","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"have a N, b Q, c R","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"prop g(x R)
prop s(x R)
prop q(x R)

know:
    forall x R: $g(x) => $s(x)
    forall x R: $s(x) => $q(x)
    not $q(17)

claim:
    not $g(17)
    prove_by_contradiction:
        $s(17)
        $q(17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# claim an Object x in R and make x > 1
let x R:
    x > 1","True"
"""""""
some comment
some comment
some comment
""""""","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"# The follow code will output unknown
1 = 2","False"
"# The follow code will output error
You can checkout any time you like but you can never leave.
What the F**K are you talking about?","False"
"# The follow code will output error
1","False"
"1 = 1","True"
"let a N: a = 2","True"
"let a N: a = 2, a = 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"claim:
	forall x, y R:
        x = -4
        y = 6
        =>:
            2 * x + 3 * y = 10
            4 * x + 5 * y = 14
    prove:
        =:
            10
            2 * -4 + 3 * 6
            2 * x + 3 * y
        =:
            14
            4 * -4 + 5 * 6
            4 * x + 5 * y","True"
"""""""
Basics
""""""

forall x R, a R, b R:
    a + x = b
    =>:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    =>:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        =>:
            b - a > 0

    forall a R, b R:
        b > a
        =>:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        =>:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    <=>:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know @exist x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    <=>:
        x $in s
        $is_smallest_element_of(x, s)
    
know forall x Z, y Z => x * y $in Z, x + y $in Z, x - y $in Z

know forall x N, y N => x + y $in N, x * y $in N

know forall x N, y N => x + y $in N, x * y $in N


 """"""
Chapter 1
""""""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    let x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        =>:
            b / a $in Q

""""""
Chapter 2
""""""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist q Z st exist_largest_multiple_of(d Z, a Z):
    <=>:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    <=>:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        =>:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        =>:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        =>:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z: d != 0, a $is_divisible_by d, b $is_divisible_by d => gcd(a, b) $is_divisible_by d

""""""
Chapter 3
""""""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know:
    forall a Z, b Z:
        gcd(a, b) = 1
        <=>:
            $exist_relatively_prime(a, b)

# Corollary 3.1
know:
    forall a Z, b Z:
        dom:
            a != 0
            b != 0
        =>:
            a / gcd(a, b) $in Z
            b / gcd(a, b) $in Z
            gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know:
    forall a Z, b Z, d Z:
        a $is_divisible_by d
        b $is_divisible_by d
        =>:
            a + b $is_divisible_by d
            a - b $is_divisible_by d
            a * b $is_divisible_by d

# Theorem 3.2
know:
    forall a Z, b Z, d Z:
        gcd(a, d) = 1
        a*b $is_divisible_by d
        =>:
            b $is_divisible_by d

# Corollary 3.1
know:
    forall a Z, b Z, d Z:
        gcd(a, b) = 1
        gcd(a, d) = 1
        =>:
            gcd(a, b*d) = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let n N
n $in N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"=(1, 2 - 1, 1 * 1)","False"
"=:
    1
    2 - 1
    1 * 1","True"
"square_root(4) $in R","False"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"square_root(4) $in R","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"1 $in N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let x R:
  x + 2 = 5
  x = 5 - 2 = 3","True"
"let x R:
  x + 2 = 5
  x = 5 - 2 = 4","True"
"let x R:
  x + 2 = 5
  x = 4 - 2 = 4","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5","True"
"# Welcome to Litex Playground!
let x R:
x + 2 = 5","True"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5","True"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5","True"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5.","False"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5.","False"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5

x = 5 - 2","True"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5

x = (5 - 2) = 3","True"
"# Welcome to Litex Playground!
let x R:
    x + 2 = 5
x = (5 - 2) = 3","True"
"# Welcome to Litex Playground!
let x R:
(x + 2) = 5
x = (5 - 2) = 3","True"
"# Welcome to Litex Playground!
let x R:
(x + 2) = 5
x = (5 - 2) = 3","True"
"let x R:
(x + 2) = 5
x = (5 - 2) = 3","True"
"let n, m N:
    n > 0
    m > n","True"
"let n, m N:
    n > 0
    m > n
m + n > 0","True"
"let n, m N:
    n > 0
    m > n
    m + n > 0","True"
"let n, m N:
    n > 0
    m > n
    m + n > n","True"
"let n, m N:
    n > 0
    m > n
    m - n > n","True"
"let n, m N:
    n > 0
    m > n
    
    m - n > n","True"
"let n, m N:
    n > 0
    m > n

m - n > n","True"
"let n, m N:
    n > 0
    m > n
m - n > n","True"
"let n, m N:
    n > 0
    m > n
    m - n > n","True"
"let n, m N:
    n > 0
    m > n
    m - n < n","True"
"let n, m N:
    n > 0
    m > n
    m - n < m","True"
"let n, m N:
    n > 0
    m > n
    m - n < m
    m - n > m","True"
"let n, m N:
    n > 0
    m > n
    m - n < 0
    m - n > 0","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"let x R: x > 5
not x <= 5","True"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"let x, y R:
    x + y = 2
    x - y = 0

x = y
x + 1 = y + 1","True"
"let x, y R:
    x + y = 2
    x - y = 0

x = 1
y = 1","True"
"let x, y R:
    x + y = 2
    x - y = 0

x = y
x + 1 = y + 1","True"
"let x, y R:
    x + y = 2
    x - y = 0","True"
"let x, y R:
    x + y = 2
    x - y = 0

x = 1","True"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"let x, y R:
    x = y
    2*x = 2*y

x = y
x + 1 = y + 1","True"
"let x, y R:
    x = y
    2*x = 2*y

x = 1","True"
"let x, y R:
    x = y
    2*x = 2*y

x = y
x + 1 = y + 1","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = y
x + 1 = y + 1","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1","True"
"let x, y R:
    x = 1
    2*x = 2*y

y = 1","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1
y = 1","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1
y = x","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1
x = y","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1
2*x = 2*y","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1
2*x = 2*y
x = y","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1          # still true
2*x = 2*y","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1          # rule
2*x = 2*y      # rule","True"
"let x, y R:
    x = 1
    2*x = 2*y

x = 1          # rule
2*x = 2*y      # rule
x = y","True"
"let x, y R:
    x = 1
    2*x = 2*y
x = 1          # rule
2*x = 2*y      # rule
x = y","True"
"let x, y R:
    x = 1
    2*x = 2*y
x = 1          # from fact
2*x = 2      # from fact
#x = y          # fails, why?","True"
"let x, y R:
    x = 1
    2*x = 2*y

2*x = 2        # from fact
#x = y          # fails, why?","True"
"let x, y R:
    x = 1
    2*x = 2*y

2*x = 2        # ok
x = y         # fails, why?","True"
"let x, y R:
    x = 1
    2*x = 2*y

2*x = 2        # ok
x == y         # fails, why?","True"
"let x, y R:
    x = 1
    2*x = 2*y

2*x = 2        # ok
x = y          # fails, why?","True"
"let x, y R:
    x = 1
    2*x = 2*y

2*x = 2        # ok
x = y          # fails, why?","True"
"# Welcome to Litex Playground!
let x, y R:
    x = 1
    2*x = 2*y

2*x = 2        # ok
x = y          # fails","True"
"# Welcome to Litex Playground!
let x, y R:
x = 1
2*x = 2*y

2*x = 2        # ok
x = y          # fails","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"# The follow code will output unknown
1 = 2","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n N, m N","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
 2*x + 3*y = 10,
  4*x + 5*y = 14","False"
"let x, y R:
 2*x + 3*y = 10
  4*x + 5*y = 14","False"
"let x, y R:
  2*x + 3*y = 10
  4*x + 5*y = 14","True"
"let x, y R:
  2*x + 3*y = 10,
  4*x + 5*y = 14","False"
"let x, y R:
  2*x + 3*y = 10
  4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"exist_prop x R st larger_than(y R):
    y > 0
    <=>:
        x > y","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"know forall x R: or(x = 1, x = 2) => x < 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let n, m N: n > 0, m > n","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 54","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have Term nonempty_set
have I, S, K, C_, B, U Term
fn app(a Term, b Term) Term

# I = Lambda x.x
# S = lambda xyz.(xz)(yz)
# K = lambda xy.x
# C_ = lambda xyz.xzy
# B = lambda xyz.x(yz)
# U = lambda x.xx

have Value nonempty_set
have I0, K0, S0, C0, B0, U0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value
fn C1(a Term) Value
fn C2(a Term, b Term) Value
fn B1(a Term) Value
fn B2(a Term, b Term) Value
fn U1(a Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

know:
    # M0 steps down
    forall x, y Term, l List:
        M0(app(x, y), l) = M0(x, Cons(y, l))
    forall l List:
        M0(I, l) = M1(I0, l)
        M0(K, l) = M1(K0, l)
        M0(S, l) = M1(S0, l)
        M0(C_, l) = M1(C0, l)
        M0(B, l) = M1(B0, l)
        M0(U, l) = M1(U0, l)

    # M1 perform the combinators' actions
    M1(I0, Nil) = M2(I0)
    M1(K0, Nil) = M2(K0)
    M1(S0, Nil) = M2(S0)
    M1(C0, Nil) = M2(C0)
    M1(B0, Nil) = M2(B0)
    M1(U0, Nil) = M2(U0)
    forall x Term, l List:
        M1(I0, Cons(x, l)) = M0(x, l)
        M1(U0, Cons(x, l)) = M0(app(x, x), l)
        M1(K0, Cons(x, l)) = M1(K1(x), l)
        M1(S0, Cons(x, l)) = M1(S1(x), l)
        M1(C0, Cons(x, l)) = M1(C1(x), l)
        M1(B0, Cons(x, l)) = M1(B1(x), l)
        M1(K0(x), Nil) = M2(K0(x))
        M1(S1(x), Nil) = M2(S1(x))
        M1(C1(x), Nil) = M2(C1(x))
        M1(B1(x), Nil) = M2(B1(x))
    forall x, y Term, l List:
        M1(K0(x), Cons(y, l)) = M0(x, l)
        M1(S1(x), Cons(y, l)) = M1(S2(x, y), l)
        M1(C1(x), Cons(y, l)) = M1(C2(x, y), l)
        M1(B1(x), Cons(y, l)) = M1(B2(x, y), l)
        M1(S2(x, y), Nil) = M2(S2(x, y))
        M1(C2(x, y), Nil) = M2(C2(x, y))
        M1(B2(x, y), Nil) = M2(B2(x, y))
    forall x, y, z Term, l List:
        M1(S2(x, y), Cons(z, l)) = M0(app(app(x, z), app(y, z)), l)
        M1(C2(x, y), Cons(z, l)) = M0(app(app(x, z), y), l)
        M1(B2(x, y), Cons(z, l)) = M0(app(x, app(y, z)), l)

have Y Term
know:
    Y = app(app(B, U), app(app(C_, B), U))

have F Term

have program Term
know:
    program = app(Y, F)

# Hereby we noticed that ""step"" and ""evalm"" are only symbols that require transitivity
# Thus we use ""="" to simplify the program
# You can expand it to ""step"" and ""evalm"" if you want

know forall a, b Term: M0(a, Nil) = M0(b, Nil) => a = b
=:
    M0(program, Nil)
    M0(app(Y, F), Nil)
    M0(app(app(app(B, U), app(app(C_, B), U)), F), Nil)
    M0(app(app(B, U), app(app(C_, B), U)), Cons(F, Nil))
    M0(app(B, U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M0(B, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B0, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B1(U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M1(B2(U, app(app(C_, B), U)), Cons(F, Nil))
    M0(app(U, app(app(app(C_, B), U), F)), Nil)
    M0(U, Cons(app(app(app(C_, B), U), F), Nil))
    M1(U0, Cons(app(app(app(C_, B), U), F), Nil))
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)

=:
    M0(app(app(app(C_, B), U), F), Nil)
    M0(app(app(C_, B), U), Cons(F, Nil))
    M0(app(C_, B), Cons(U, Cons(F, Nil)))
    M0(C_, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C0, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C1(B), Cons(U, Cons(F, Nil)))
    M1(C2(B, U), Cons(F, Nil))
    M0(app(app(B, F), U), Nil)

app(app(app(C_, B), U), F) = app(app(B, F), U)

=:
    M0(program, Nil)
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(app(app(B, F), U), Cons(app(app(B, F), U), Nil))
    M0(app(B, F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M0(B, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B0, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B1(F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M1(B2(F, U), Cons(app(app(B, F), U), Nil))
    M0(app(F, app(U, app(app(B, F), U))), Nil)

=:
    M0(app(U, app(app(B, F), U)), Nil)
    M0(U, Cons(app(app(B, F), U), Nil))
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(program, Nil)

app(U, app(app(B, F), U)) = program

=:
    M0(program, Nil)
    M0(app(F, app(U, app(app(B, F), U))), Nil)
    M0(app(F, program), Nil)

program = app(F, program)
app(Y, F) = app(F, app(Y, F))

# Thus, we've proved the property of Y-combinator
# Y F = F(Y F)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let n, m N:
    n > 0
    m > n","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R: x > 5
not x <= 5","True"
"let x R: x > 5
not x <= 5","True"
"or:
    1 = 1
    1 = 2","True"
"or(1 = 1, 1 = 2)","True"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"=:
    1
    2 - 1
    1 * 1","True"
"=(1, 2 - 1, 1 * 1)","False"
"=( 1, 2 - 1, 1 * 1 )","False"
"= ( 1, 2 - 1, 1 * 1 )","False"
"= ( 1, 2 - 1, 1 * 1 )","False"
"= ( 1, 2 - 1, 1 * 1 )","False"
"= ( 1, 2 - 1, 1 * 1 )","False"
"1 + 1 = 2
4 / 2 = 2","True"
"2 $in N","True"
"let x N  # equivalent to let x; know x $in N","True"
"forall x N:
    x $in R","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"prop equal(A,B set):
    forall x A:
        x $in B
    forall x B:
        x $in A 
    
have empty_set set
know:
    forall x obj:
        not $in(x, empty_set)

prop inter(x obj, A,B set):
    x $in A
    x $in B
fn interset(A,B set) set:
   forall x interset(A,B):
      $inter(x,A,B)
   forall x obj:
      $inter(x,A,B)
      =>:
        x $in interset(A,B)

claim:
    forall A set,x obj:
       x $in empty_set
       =>:
         x $in A
    prove_by_contradiction:
       not x $in empty_set 

forall A set:
    forall x empty_set:
       x $in A
       x $in interset(A,empty_set)
    forall x interset(A,empty_set):
       $inter(x,A,empty_set)
       x $in empty_set
    $equal(interset(A,empty_set),empty_set)","True"
"prop equal(A,B set):
    forall x A:
        x $in B
    forall x B:
        x $in A 
    
have empty_set set
know:
    forall x obj:
        not $in(x, empty_set)

prop inter(x obj, A,B set):
    x $in A
    x $in B
fn interset(A,B set) set:
   forall x interset(A,B):
      $inter(x,A,B)
   forall x obj:
      $inter(x,A,B)
      =>:
        x $in interset(A,B)

claim:
    forall A set,x obj:
       x $in empty_set
       =>:
         x $in A
    prove_by_contradiction:
       not x $in empty_set 

forall A set:
    forall x empty_set:
       x $in A
       x $in interset(A,empty_set)
    forall x interset(A,empty_set):
       $inter(x,A,empty_set)
       x $in empty_set
    $equal(interset(A,empty_set),empty_set)","True"
"# Litex for Basic Math - Part I
# set reflexivity

forall A set:
    =>:
        forall x A => x $in A","True"
"# Litex for Basic Math - Part I
# set reflexivity

forall A set:
    =>:
        forall x A => x $in A","True"
"# Litex for Basic Math - Part I
# set reflexivity

forall A set:
    =>:
        forall x A => x $in A","True"
"# Litex for Basic Math - Part I
# set reflexivity

forall A set:
    =>:
        forall x A => x $in A","True"
"# Litex for Basic Math - Part I
# set reflexivity

forall A set:
    =>:
        forall x A => x $in A","True"
"# Litex for Basic Math - Part I
# set reflexivity

forall A set:
    =>:
        forall x A => x $in A","True"
"# Litex for Basic Math - Part I
# least common multiple

exist_prop k Z st divides(a, b Z): 
    a != 0
    <=>:  
        b = a * k

fn lcm(a N, b N) N:  
    forall m N:
        $divides(a, m) and $divides(b, m)  
        =>:
            $divides(lcm(a, b), m)    
    forall m N:  
        $divides(a, lcm(a,b)) and $divides(b, lcm(a,b))","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let a N: a = 2, a = 3","True"
"let self_defined_empty_set set: forall x obj => not x $in self_defined_empty_set","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"1=1","True"
"2^100=2","False"
"2^100=2^100","True"
"2^100=2*2^100","False"
"2^100=2*2^99","True"
"2^100=2*7","False"
"2^100=k","False"
"2.3 $in N","False"
"2.3 $in Q","True"
"2^3884 $in Z","True"
"2^3^84 $in Z","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N: n > 0, m > n","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"let a N: a = 2, a = 3","True"
"let a N: a = 2, a = 3","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n, m N:
    n > 0
    m > n","True"
"let a N: a = 2, a = 3","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"claim:
    forall x R: or(x = 2, x = -2) => x ^ 2 = 4
    prove:
        prove_in_each_case:
            or(x = 2, x = -2)
            =>:
                x ^ 2 = 4
            prove:
                2 ^ 2 = 4
            prove:
                -2 ^ 2 = 4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"1 = 1","True"
"1 = 1  * 1","True"
"let a R: a = 1
a = 1","True"
"let a R: a = 1
a = 1","True"
"1 $in R
1 $in Z
1 $in Q","True"
"claim:
    forall total_animals, total_legs, step1, step2, chickens N_pos:
        total_animals = 20
        total_legs = 70
        step1 = 4 * total_animals
        step2 = step1 - total_legs
        chickens = step2 / 2
        =>:
            chickens = 5
    prove:
        step1 = 4 * 20
        step1 = 80
        step2 = 80 - 70
        step2 = 10
        chickens = 10 / 2
        chickens = 5","True"
"let x R:
    x + 2 = 5

x = (5 -2) = 4","True"
"let x R:
    x + 2 = 5
    x = (5-2) = 4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Welcome to Litex Playground!
let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14","True"
"# Welcome to Litex Playground!
let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10","True"
"# Welcome to Litex Playground!
let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4 * x + 6 * y = 2 * 10","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"claim:
	forall x, y R:
        x = -4
        y = 6
        =>:
            2 * x + 3 * y = 10
            4 * x + 5 * y = 14
    prove:
        =:
            10
            2 * -4 + 3 * 6
            2 * x + 3 * y
        =:
            14
            4 * -4 + 5 * 6
            4 * x + 5 * y","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let n, m N: n > 0, m > n","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"# The follow code will output unknown
1 = 2","False"
"# The follow code will output error
You can checkout any time you like but you can never leave.
What the F**K are you talking about?","False"
"# The follow code will output error
1","False"
"have a N, b Q, c R
let e N, f Q, g R","True"
"let a N: a = 2","True"
"let a N: a = 2, a = 3","True"
"let self_defined_empty_set set: forall x obj => not x $in self_defined_empty_set","True"
"exist_prop x R st exist_number_larger_than(y R):
    x > y

exist 17 st $exist_number_larger_than(1)

$exist_number_larger_than(1)

have a st $exist_number_larger_than(1)

a $in R
a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"have a N, b Q, c R","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"2 $in N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + y = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R
let e N, f Q, g R","True"
"let a N: a = 2","True"
"let a N: a = 2, a = 3","True"
"let self_defined_empty_set set: forall x obj => not x $in self_defined_empty_set","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14","True"
"let x, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14","True"
"have set s2 := n N:
    n > 0
    n < 4","True"
"prop can_form_a_triangle(x, y, z R):
    dom:
        x > 0
        y > 0
        z > 0
    <=>:
        x + y > z
        x + z > y
        y + z > x","True"
"let happy_baby_characters set
let little_little_monster, big_big_monster, boss, happy_superman happy_baby_characters

# Transitivity
prop is_leader_of(x, y happy_baby_characters)
know big_big_monster $is_leader_of little_little_monster, boss $is_leader_of big_big_monster
prop is_leader_is_transitive(x, y, z happy_baby_characters):
    x $is_leader_of y
    y $is_leader_of z
    <=>:
        x $is_leader_of z
know forall x, y, z happy_baby_characters: x $is_leader_of y, y $is_leader_of z => $is_leader_is_transitive(x, y, z)
$is_leader_is_transitive(boss, big_big_monster, little_little_monster)
boss $is_leader_of little_little_monster

# Commutativity
prop is_enemy_of(x, y happy_baby_characters)
know forall x, y happy_baby_characters => x $is_enemy_of y <=> y $is_enemy_of x; happy_superman $is_enemy_of big_big_monster
big_big_monster $is_enemy_of happy_superman

# Reflexivity
prop is_friend_of(x, y happy_baby_characters)
know forall x happy_baby_characters => x $is_friend_of x
little_little_monster $is_friend_of little_little_monster","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have Term nonempty_set
have I, S, K, C_, B, U Term
fn app(a Term, b Term) Term

# I = Lambda x.x
# S = lambda xyz.(xz)(yz)
# K = lambda xy.x
# C_ = lambda xyz.xzy
# B = lambda xyz.x(yz)
# U = lambda x.xx

have Value nonempty_set
have I0, K0, S0, C0, B0, U0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value
fn C1(a Term) Value
fn C2(a Term, b Term) Value
fn B1(a Term) Value
fn B2(a Term, b Term) Value
fn U1(a Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

know:
    # M0 steps down
    forall x, y Term, l List:
        M0(app(x, y), l) = M0(x, Cons(y, l))
    forall l List:
        M0(I, l) = M1(I0, l)
        M0(K, l) = M1(K0, l)
        M0(S, l) = M1(S0, l)
        M0(C_, l) = M1(C0, l)
        M0(B, l) = M1(B0, l)
        M0(U, l) = M1(U0, l)

    # M1 perform the combinators' actions
    M1(I0, Nil) = M2(I0)
    M1(K0, Nil) = M2(K0)
    M1(S0, Nil) = M2(S0)
    M1(C0, Nil) = M2(C0)
    M1(B0, Nil) = M2(B0)
    M1(U0, Nil) = M2(U0)
    forall x Term, l List:
        M1(I0, Cons(x, l)) = M0(x, l)
        M1(U0, Cons(x, l)) = M0(app(x, x), l)
        M1(K0, Cons(x, l)) = M1(K1(x), l)
        M1(S0, Cons(x, l)) = M1(S1(x), l)
        M1(C0, Cons(x, l)) = M1(C1(x), l)
        M1(B0, Cons(x, l)) = M1(B1(x), l)
        M1(K0(x), Nil) = M2(K0(x))
        M1(S1(x), Nil) = M2(S1(x))
        M1(C1(x), Nil) = M2(C1(x))
        M1(B1(x), Nil) = M2(B1(x))
    forall x, y Term, l List:
        M1(K0(x), Cons(y, l)) = M0(x, l)
        M1(S1(x), Cons(y, l)) = M1(S2(x, y), l)
        M1(C1(x), Cons(y, l)) = M1(C2(x, y), l)
        M1(B1(x), Cons(y, l)) = M1(B2(x, y), l)
        M1(S2(x, y), Nil) = M2(S2(x, y))
        M1(C2(x, y), Nil) = M2(C2(x, y))
        M1(B2(x, y), Nil) = M2(B2(x, y))
    forall x, y, z Term, l List:
        M1(S2(x, y), Cons(z, l)) = M0(app(app(x, z), app(y, z)), l)
        M1(C2(x, y), Cons(z, l)) = M0(app(app(x, z), y), l)
        M1(B2(x, y), Cons(z, l)) = M0(app(x, app(y, z)), l)

have Y Term
know:
    Y = app(app(B, U), app(app(C_, B), U))

have F Term

have program Term
know:
    program = app(Y, F)

# Hereby we noticed that ""step"" and ""evalm"" are only symbols that require transitivity
# Thus we use ""="" to simplify the program
# You can expand it to ""step"" and ""evalm"" if you want

know forall a, b Term: M0(a, Nil) = M0(b, Nil) => a = b
=:
    M0(program, Nil)
    M0(app(Y, F), Nil)
    M0(app(app(app(B, U), app(app(C_, B), U)), F), Nil)
    M0(app(app(B, U), app(app(C_, B), U)), Cons(F, Nil))
    M0(app(B, U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M0(B, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B0, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B1(U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M1(B2(U, app(app(C_, B), U)), Cons(F, Nil))
    M0(app(U, app(app(app(C_, B), U), F)), Nil)
    M0(U, Cons(app(app(app(C_, B), U), F), Nil))
    M1(U0, Cons(app(app(app(C_, B), U), F), Nil))
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)

=:
    M0(app(app(app(C_, B), U), F), Nil)
    M0(app(app(C_, B), U), Cons(F, Nil))
    M0(app(C_, B), Cons(U, Cons(F, Nil)))
    M0(C_, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C0, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C1(B), Cons(U, Cons(F, Nil)))
    M1(C2(B, U), Cons(F, Nil))
    M0(app(app(B, F), U), Nil)

app(app(app(C_, B), U), F) = app(app(B, F), U)

=:
    M0(program, Nil)
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(app(app(B, F), U), Cons(app(app(B, F), U), Nil))
    M0(app(B, F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M0(B, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B0, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B1(F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M1(B2(F, U), Cons(app(app(B, F), U), Nil))
    M0(app(F, app(U, app(app(B, F), U))), Nil)

=:
    M0(app(U, app(app(B, F), U)), Nil)
    M0(U, Cons(app(app(B, F), U), Nil))
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(program, Nil)

app(U, app(app(B, F), U)) = program

=:
    M0(program, Nil)
    M0(app(F, app(U, app(app(B, F), U))), Nil)
    M0(app(F, program), Nil)

program = app(F, program)
app(Y, F) = app(F, app(Y, F))

# Thus, we've proved the property of Y-combinator
# Y F = F(Y F)","True"
"# Welcome to Litex Playground!

x=2
x-3","False"
"# Welcome to Litex Playground!

x=2
y=x-3","False"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"let weekdays set
prop is_monday(x weekdays)
prop is_tuesday(x weekdays)
prop is_wednesday(x weekdays)
prop is_thursday(x weekdays)
prop is_friday(x weekdays)
prop is_saturday(x weekdays)
prop is_sunday(x weekdays)
know forall x weekdays => or($is_monday(x), $is_tuesday(x), $is_wednesday(x), $is_thursday(x), $is_friday(x), $is_saturday(x), $is_sunday(x))

prop stay_at_home_doctor_wear_his_uniform(x weekdays)
know:
    forall x weekdays: $is_monday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_tuesday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_wednesday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_thursday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_friday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_saturday(x) => $stay_at_home_doctor_wear_his_uniform(x)
    forall x weekdays: $is_sunday(x) => $stay_at_home_doctor_wear_his_uniform(x)

prop stay_at_home_doctor_always_wear_his_uniform():
    forall x weekdays => $stay_at_home_doctor_wear_his_uniform(x)

claim:
    forall x weekdays => $stay_at_home_doctor_wear_his_uniform(x)
    prove:
        prove_in_each_case:
            or($is_monday(x), $is_tuesday(x), $is_wednesday(x), $is_thursday(x), $is_friday(x), $is_saturday(x), $is_sunday(x))
            =>:
                $stay_at_home_doctor_wear_his_uniform(x)
            prove:
                $is_monday(x)
            prove:
                $is_tuesday(x)
            prove:
                $is_wednesday(x)
            prove:
                $is_thursday(x)
            prove:
                $is_friday(x)
            prove:
                $is_saturday(x)
            prove:
                $is_sunday(x)

$stay_at_home_doctor_always_wear_his_uniform()","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let n, m N:
    n > 0
    m > n","True"
"let n, m N: n > 0, m > n","True"
"let n N, m N","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"have set one_to_five := {1,2,3,4,5}","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"=:
    1
    2 - 1
    1 * 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(3)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(2)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(0)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(0)  # a $in R, a > 1
    
have a st $larger_than(0)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(0)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"forall x R: x = 1 => x = 1","True"
"forall x R: x = 1 => not x = 2 <=> x != 2","True"
"forall x R:
    dom:
        x = 1
    =>:
        x != 2
    <=>:
        not x = 2","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"let x R
know:
    x > 0
    x != 2
    forall y R:
        y > 5
        =>:
            y > x","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"prop transitivity_of_less(a, b, c R):
    a < b
    b < c

know:
    forall a, b, c R:
        $transitivity_of_less(a, b, c)
        =>:
            a < c
    forall a, b, c R:
        a < b
        b < c
        =>:
            a < c","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"fn f(x R) R:
    dom:
        x > 0
    =>:
        f(x) > 0","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"have fn g(x R) R = x","True"
"fn_template sequence(s set):
    fn (n N) s","True"
"fn_template finite_sequence(s set, max N):
    dom:
        max > 0
    fn (n N) s:
        dom:
            n < max","True"
"let a sequence(R), b finite_sequence(Z, 10)","True"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"square_root(4) $in R","False"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x

square_root(4) $in R","True"
"let x R: x > 5
not x <= 5","True"
"or:
    1 = 1
    1 = 2","True"
"or(1 = 1, 1 = 2)","True"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"=:
    1
    2 - 1
    1 * 1","True"
"=(1, 2 - 1, 1 * 1)","False"
"1 + 1 = 2
4 / 2 = 2","True"
"2 $in N","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"prop p(x R, n N_pos)
let x R
know forall n N_pos: n >= 1, $p(x, n) => $p(x, n+1)
know $p(x, 1)

prove_by_induction($p(x, n), n, 1)","True"
"prop p(x R)
have set s := {1, 2, 3}

prove_over_finite_set:
    forall x s:
        x > 0
    prove:
        1 > 0
    prove:
        2 > 0
    prove:
        3 > 0","True"
"1 > 0, forall x R => x $in R; 2 > 1","True"
"forall x R: x > 0 => x > 0","True"
"know forall x R => or(x > 1, x = 1, x < 1)

let x R
or(x > 1, x = 1, x < 1)","True"
"let x, y, z :
    x = y
    y = z

=(x, y, z)","False"
"know forall x R => or(x > 1, x = 1, x < 1)

let x, y, z :
    x = y
    y = z

=(x, y, z)","False"
"1 = 1","True"
"let x R: x > 0","True"
"let x R: x > 0
f(x) > 0","True"
"# numeric facts
1 + 1 = 2
17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"# numeric facts
1 + 1 = 2
17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R
0 $in N_pos","True"
"# numeric facts
1 + 1 = 2
17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R
1 $in N_pos","True"
"# built-in sequence templates
let a seq(R), b finite_seq(Z, 10)

a(1) $in R
b(1) $in Z","True"
"import ""file.lix""","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# claim an Object x in R and make x > 1
let x R:
    x > 1","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"# The follow code will output error
You can checkout any time you like but you can never leave.
What the F**K are you talking about?","False"
"have a N, b Q, c R
let e N, f Q, g R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R
let e N, f Q, g R","True"
"let a N: a = 2, a = 3","True"
"let self_defined_empty_set set: forall x obj => not x $in self_defined_empty_set","True"
"exist_prop x R st exist_number_larger_than(y R):
    x > y

exist 17 st $exist_number_larger_than(1)

$exist_number_larger_than(1)

have a st $exist_number_larger_than(1)

a $in R
a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop g(x R)
prop s(x R)
prop q(x R)

know:
    forall x R: $g(x) => $s(x)
    forall x R: $s(x) => $q(x)
    not $q(17)

claim:
    not $g(17)
    prove_by_contradiction:
        $s(17)
        $q(17)","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"1 $in N","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"forall x R: x > 0 => x > 0","True"
"let x, y, z :
    x = y
    y = z

=(x, y, z)","False"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"know forall x N: x >= 47 => x >= 17
let x N: x = 47
x >= 17","True"
"know forall x N: x >= 47 => x >= 17
let x N: x = 47
x >= 17","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
    
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n N, m N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have Term nonempty_set
have I, S, K, C_, B, U Term
fn app(a Term, b Term) Term

# I = Lambda x.x
# S = lambda xyz.(xz)(yz)
# K = lambda xy.x
# C_ = lambda xyz.xzy
# B = lambda xyz.x(yz)
# U = lambda x.xx

have Value nonempty_set
have I0, K0, S0, C0, B0, U0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value
fn C1(a Term) Value
fn C2(a Term, b Term) Value
fn B1(a Term) Value
fn B2(a Term, b Term) Value
fn U1(a Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

know:
    # M0 steps down
    forall x, y Term, l List:
        M0(app(x, y), l) = M0(x, Cons(y, l))
    forall l List:
        M0(I, l) = M1(I0, l)
        M0(K, l) = M1(K0, l)
        M0(S, l) = M1(S0, l)
        M0(C_, l) = M1(C0, l)
        M0(B, l) = M1(B0, l)
        M0(U, l) = M1(U0, l)

    # M1 perform the combinators' actions
    M1(I0, Nil) = M2(I0)
    M1(K0, Nil) = M2(K0)
    M1(S0, Nil) = M2(S0)
    M1(C0, Nil) = M2(C0)
    M1(B0, Nil) = M2(B0)
    M1(U0, Nil) = M2(U0)
    forall x Term, l List:
        M1(I0, Cons(x, l)) = M0(x, l)
        M1(U0, Cons(x, l)) = M0(app(x, x), l)
        M1(K0, Cons(x, l)) = M1(K1(x), l)
        M1(S0, Cons(x, l)) = M1(S1(x), l)
        M1(C0, Cons(x, l)) = M1(C1(x), l)
        M1(B0, Cons(x, l)) = M1(B1(x), l)
        M1(K0(x), Nil) = M2(K0(x))
        M1(S1(x), Nil) = M2(S1(x))
        M1(C1(x), Nil) = M2(C1(x))
        M1(B1(x), Nil) = M2(B1(x))
    forall x, y Term, l List:
        M1(K0(x), Cons(y, l)) = M0(x, l)
        M1(S1(x), Cons(y, l)) = M1(S2(x, y), l)
        M1(C1(x), Cons(y, l)) = M1(C2(x, y), l)
        M1(B1(x), Cons(y, l)) = M1(B2(x, y), l)
        M1(S2(x, y), Nil) = M2(S2(x, y))
        M1(C2(x, y), Nil) = M2(C2(x, y))
        M1(B2(x, y), Nil) = M2(B2(x, y))
    forall x, y, z Term, l List:
        M1(S2(x, y), Cons(z, l)) = M0(app(app(x, z), app(y, z)), l)
        M1(C2(x, y), Cons(z, l)) = M0(app(app(x, z), y), l)
        M1(B2(x, y), Cons(z, l)) = M0(app(x, app(y, z)), l)

have Y Term
know:
    Y = app(app(B, U), app(app(C_, B), U))

have F Term

have program Term
know:
    program = app(Y, F)

# Hereby we noticed that ""step"" and ""evalm"" are only symbols that require transitivity
# Thus we use ""="" to simplify the program
# You can expand it to ""step"" and ""evalm"" if you want

know forall a, b Term: M0(a, Nil) = M0(b, Nil) => a = b
=:
    M0(program, Nil)
    M0(app(Y, F), Nil)
    M0(app(app(app(B, U), app(app(C_, B), U)), F), Nil)
    M0(app(app(B, U), app(app(C_, B), U)), Cons(F, Nil))
    M0(app(B, U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M0(B, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B0, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B1(U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M1(B2(U, app(app(C_, B), U)), Cons(F, Nil))
    M0(app(U, app(app(app(C_, B), U), F)), Nil)
    M0(U, Cons(app(app(app(C_, B), U), F), Nil))
    M1(U0, Cons(app(app(app(C_, B), U), F), Nil))
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)

=:
    M0(app(app(app(C_, B), U), F), Nil)
    M0(app(app(C_, B), U), Cons(F, Nil))
    M0(app(C_, B), Cons(U, Cons(F, Nil)))
    M0(C_, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C0, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C1(B), Cons(U, Cons(F, Nil)))
    M1(C2(B, U), Cons(F, Nil))
    M0(app(app(B, F), U), Nil)

app(app(app(C_, B), U), F) = app(app(B, F), U)

=:
    M0(program, Nil)
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(app(app(B, F), U), Cons(app(app(B, F), U), Nil))
    M0(app(B, F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M0(B, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B0, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B1(F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M1(B2(F, U), Cons(app(app(B, F), U), Nil))
    M0(app(F, app(U, app(app(B, F), U))), Nil)

=:
    M0(app(U, app(app(B, F), U)), Nil)
    M0(U, Cons(app(app(B, F), U), Nil))
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(program, Nil)

app(U, app(app(B, F), U)) = program

=:
    M0(program, Nil)
    M0(app(F, app(U, app(app(B, F), U))), Nil)
    M0(app(F, program), Nil)

program = app(F, program)
app(Y, F) = app(F, app(Y, F))

# Thus, we've proved the property of Y-combinator
# Y F = F(Y F)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"axiom AllHumansMortal: ∀x. Human(x) → Mortal(x)
axiom SocratesHuman: Human(Socrates)

theorem SocratesMortal: Mortal(Socrates)
proof
    have Human(Socrates)            by SocratesHuman
        have Human(Socrates) → Mortal(Socrates)  by AllHumansMortal
            thus Mortal(Socrates)           by ModusPonens
            qed","False"
"axiom AllHumansMortal: ∀x. Human(x) → Mortal(x)
axiom SocratesHuman: Human(Socrates)

theorem SocratesMortal: Mortal(Socrates)
proof:
  have Human(Socrates) by SocratesHuman
    have Human(Socrates) → Mortal(Socrates) by AllHumansMortal
      thus Mortal(Socrates) by ModusPonens
      qed","False"
"theorem SocratesMortal: Mortal(Socrates)
proof:
  have Human(Socrates) by SocratesHuman
    have Human(Socrates) → Mortal(Socrates) by AllHumansMortal
      hence Mortal(Socrates)
      qed","False"
"have a N, b Q, c R","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"exist_prop x R st larger_than(y R):
    dom:
        y > 0
    <=>:
        x > y","True"
"exist_prop x R st larger_than(y R):
    dom:
        y > 0
    <=>:
        x > y","True"
"exist_prop x R st larger_than(y R):
    dom:
        y > 0
    <=>:
        x > y","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R
have b Q","True"
"let n N, m N
let m N","True"
"have a N, b Q, c R
have b Q","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"17 < 47 # verb: <, nouns: 17, 47
17 * 47 = 799 # verb: =, nouns: 17 * 47, 799
17 != 47 # verb: !=, nouns: 17, 47","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"let s set:
    s := {1, 2, 3}

prove_over_finite_set:
    forall x s:
        x > 0","True"
"have set s := {}

# any factual statement is true on empty set
prove_over_finite_set:
    forall x s:
        x > 0
        x < 0","True"
"let s3, s4 set:
    s3 := {1, 2, 3}
    s4 := {1, 2, 3}

prove_over_finite_set:
    forall x s3, y s4:
        x * y >= 1","True"
"let s1 set, s2 set:
    s1 := {1, 2}
    s2 := {3, 4}

prove_over_finite_set:
    forall x s1, y s2:
        x * y >= 1
    prove:
        1 * 3 >= 1
    prove:
        1 * 4 >= 1
    prove:
        2 * 3 >= 1
    prove:
        2 * 4 >= 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let n, m N: n > 0, m > n","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n, m N: n > 0, m > n","True"
"let n, m N: n > 0, m > n","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"1 + 1 = 2
1 != 2
3 < x","True"
"1 + 1 = 2
1 != 2
3 < 0","True"
"1 + 1 = 3
1 != 2
3 < 0","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"2 $in N","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R: x = 1

or:
    x = 1
    x = 2

or(x = 1, x = 2)","True"
"have set one_to_five := {1,2,3,4,5}","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# claim an Object x in R and make x > 1
let x R:
    x > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"have a N, b Q, c R
let e N, f Q, g R","True"
"let a N: a = 2","True"
"let a, b R:
    b > a","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"1 + 1 = 2
2 * (1 + 1) = 3 + 1
have x, y, z R
(x + 1) ^ 2 = x ^ 2 + 2 * x + 1
(x + y) * (x + z) = x ^ 2 + x * y + x * z + y * z
x + z = z + x","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let a N: a = 2, a = 3","True"
"let a N: a = 2, a = 3","True"
"let a N: a = 2, a = 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"let x R
know:
    x > 0
    x != 2
    forall y R:
        y > 5
        =>:
            y > x","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"let n, m N: n > 0, m > n","True"
"1 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"have a N, b Q, c R","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        a * x^2 + b * x + c = 0
        b^2 - 4 * a * c >= 0
        a != 0
        =>:
            or:
                x = (-b + sqrt(b^2 - 4*a*c))/(2*a)
                x = (-b - sqrt(b^2 - 4*a*c))/(2*a)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","False"
"claim:
    forall a, b, c, x R:
        a * x^2 + b * x + c = 0
        b^2 - 4 * a * c >= 0
        a != 0
        =>:
            or:
                x = (-b + sqrt(b^2 - 4*a*c))/(2*a)
                x = (-b - sqrt(b^2 - 4*a*c))/(2*a)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","False"
"claim:
    forall a, b, c, x R:
        a * x^2 + b * x + c = 0
        b^2 - 4 * a * c >= 0
        a != 0
        =>:
            or:
                x = (-b + sqrt(b^2 - 4*a*c))/(2*a)
                x = (-b - sqrt(b^2 - 4*a*c))/(2*a)
    prove:
        =:
            sqrt(b^2 - 4 * a * c) * sqrt(b^2 - 4 * a * c)
            sqrt(b^2 - 4 * a * c) ^ 2
            b^2 - 4 * a * c
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","False"
"claim:
    forall a, b, c, x R:
        a * x^2 + b * x + c = 0
        b^2 - 4 * a * c >= 0
        a != 0
        =>:
            or:
                x = (-b + sqrt(b^2 - 4*a*c))/(2*a)
                x = (-b - sqrt(b^2 - 4*a*c))/(2*a)
    prove:
        =:
            sqrt(b^2 - 4 * a * c) * sqrt(b^2 - 4 * a * c)
            sqrt(b^2 - 4 * a * c) ^ 2
            b^2 - 4 * a * c
        =:
            (x + b - sqrt(b^2 - 4 * a * c)) * (x + b + sqrt(b^2 - 4 * a * c))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","False"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have Term nonempty_set
have I, S, K, C_, B, U Term
fn app(a Term, b Term) Term

# I = Lambda x.x
# S = lambda xyz.(xz)(yz)
# K = lambda xy.x
# C_ = lambda xyz.xzy
# B = lambda xyz.x(yz)
# U = lambda x.xx

have Value nonempty_set
have I0, K0, S0, C0, B0, U0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value
fn C1(a Term) Value
fn C2(a Term, b Term) Value
fn B1(a Term) Value
fn B2(a Term, b Term) Value
fn U1(a Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

know:
    # M0 steps down
    forall x, y Term, l List:
        M0(app(x, y), l) = M0(x, Cons(y, l))
    forall l List:
        M0(I, l) = M1(I0, l)
        M0(K, l) = M1(K0, l)
        M0(S, l) = M1(S0, l)
        M0(C_, l) = M1(C0, l)
        M0(B, l) = M1(B0, l)
        M0(U, l) = M1(U0, l)

    # M1 perform the combinators' actions
    M1(I0, Nil) = M2(I0)
    M1(K0, Nil) = M2(K0)
    M1(S0, Nil) = M2(S0)
    M1(C0, Nil) = M2(C0)
    M1(B0, Nil) = M2(B0)
    M1(U0, Nil) = M2(U0)
    forall x Term, l List:
        M1(I0, Cons(x, l)) = M0(x, l)
        M1(U0, Cons(x, l)) = M0(app(x, x), l)
        M1(K0, Cons(x, l)) = M1(K1(x), l)
        M1(S0, Cons(x, l)) = M1(S1(x), l)
        M1(C0, Cons(x, l)) = M1(C1(x), l)
        M1(B0, Cons(x, l)) = M1(B1(x), l)
        M1(K0(x), Nil) = M2(K0(x))
        M1(S1(x), Nil) = M2(S1(x))
        M1(C1(x), Nil) = M2(C1(x))
        M1(B1(x), Nil) = M2(B1(x))
    forall x, y Term, l List:
        M1(K0(x), Cons(y, l)) = M0(x, l)
        M1(S1(x), Cons(y, l)) = M1(S2(x, y), l)
        M1(C1(x), Cons(y, l)) = M1(C2(x, y), l)
        M1(B1(x), Cons(y, l)) = M1(B2(x, y), l)
        M1(S2(x, y), Nil) = M2(S2(x, y))
        M1(C2(x, y), Nil) = M2(C2(x, y))
        M1(B2(x, y), Nil) = M2(B2(x, y))
    forall x, y, z Term, l List:
        M1(S2(x, y), Cons(z, l)) = M0(app(app(x, z), app(y, z)), l)
        M1(C2(x, y), Cons(z, l)) = M0(app(app(x, z), y), l)
        M1(B2(x, y), Cons(z, l)) = M0(app(x, app(y, z)), l)

have Y Term
know:
    Y = app(app(B, U), app(app(C_, B), U))

have F Term

have program Term
know:
    program = app(Y, F)

# Hereby we noticed that ""step"" and ""evalm"" are only symbols that require transitivity
# Thus we use ""="" to simplify the program
# You can expand it to ""step"" and ""evalm"" if you want

know forall a, b Term: M0(a, Nil) = M0(b, Nil) => a = b
=:
    M0(program, Nil)
    M0(app(Y, F), Nil)
    M0(app(app(app(B, U), app(app(C_, B), U)), F), Nil)
    M0(app(app(B, U), app(app(C_, B), U)), Cons(F, Nil))
    M0(app(B, U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M0(B, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B0, Cons(U, Cons(app(app(C_, B), U), Cons(F, Nil))))
    M1(B1(U), Cons(app(app(C_, B), U), Cons(F, Nil)))
    M1(B2(U, app(app(C_, B), U)), Cons(F, Nil))
    M0(app(U, app(app(app(C_, B), U), F)), Nil)
    M0(U, Cons(app(app(app(C_, B), U), F), Nil))
    M1(U0, Cons(app(app(app(C_, B), U), F), Nil))
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)

=:
    M0(app(app(app(C_, B), U), F), Nil)
    M0(app(app(C_, B), U), Cons(F, Nil))
    M0(app(C_, B), Cons(U, Cons(F, Nil)))
    M0(C_, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C0, Cons(B,Cons(U, Cons(F, Nil))))
    M1(C1(B), Cons(U, Cons(F, Nil)))
    M1(C2(B, U), Cons(F, Nil))
    M0(app(app(B, F), U), Nil)

app(app(app(C_, B), U), F) = app(app(B, F), U)

=:
    M0(program, Nil)
    M0(app(app(app(app(C_, B), U), F), app(app(app(C_, B), U), F)), Nil)
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(app(app(B, F), U), Cons(app(app(B, F), U), Nil))
    M0(app(B, F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M0(B, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B0, Cons(F, Cons(U, Cons(app(app(B, F), U), Nil))))
    M1(B1(F), Cons(U, Cons(app(app(B, F), U), Nil)))
    M1(B2(F, U), Cons(app(app(B, F), U), Nil))
    M0(app(F, app(U, app(app(B, F), U))), Nil)

=:
    M0(app(U, app(app(B, F), U)), Nil)
    M0(U, Cons(app(app(B, F), U), Nil))
    M0(app(app(app(B, F), U), app(app(B, F), U)), Nil)
    M0(program, Nil)

app(U, app(app(B, F), U)) = program

=:
    M0(program, Nil)
    M0(app(F, app(U, app(app(B, F), U))), Nil)
    M0(app(F, program), Nil)

program = app(F, program)
app(Y, F) = app(F, app(Y, F))

# Thus, we've proved the property of Y-combinator
# Y F = F(Y F)","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n, m N: n > 0, m > n","True"
"have a N, b Q, c R","True"
"let a N: a = 2, a = 3","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"17 < 47 # verb: <, nouns: 17, 47
17 * 47 = 799 # verb: =, nouns: 17 * 47, 799
17 != 47 # verb: !=, nouns: 17, 47","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop p(x R)","True"
"prop p(x R)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# Welcome to Litex Playground!
have","False"
"# Welcome to Litex Playground!
have","False"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"""""""
Basics
""""""

forall x R, a R, b R:
    a + x = b
    =>:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    =>:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        =>:
            b - a > 0

    forall a R, b R:
        b > a
        =>:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        =>:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    <=>:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know @exist x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    <=>:
        x $in s
        $is_smallest_element_of(x, s)
    
know forall x Z, y Z => x * y $in Z, x + y $in Z, x - y $in Z

know forall x N, y N => x + y $in N, x * y $in N

know forall x N, y N => x + y $in N, x * y $in N


 """"""
Chapter 1
""""""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    let x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        =>:
            b / a $in Q

""""""
Chapter 2
""""""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist q Z st exist_largest_multiple_of(d Z, a Z):
    <=>:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    <=>:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        =>:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        =>:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        =>:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z: d != 0, a $is_divisible_by d, b $is_divisible_by d => gcd(a, b) $is_divisible_by d

""""""
Chapter 3
""""""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know:
    forall a Z, b Z:
        gcd(a, b) = 1
        <=>:
            $exist_relatively_prime(a, b)

# Corollary 3.1
know:
    forall a Z, b Z:
        dom:
            a != 0
            b != 0
        =>:
            a / gcd(a, b) $in Z
            b / gcd(a, b) $in Z
            gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know:
    forall a Z, b Z, d Z:
        a $is_divisible_by d
        b $is_divisible_by d
        =>:
            a + b $is_divisible_by d
            a - b $is_divisible_by d
            a * b $is_divisible_by d

# Theorem 3.2
know:
    forall a Z, b Z, d Z:
        gcd(a, d) = 1
        a*b $is_divisible_by d
        =>:
            b $is_divisible_by d

# Corollary 3.1
know:
    forall a Z, b Z, d Z:
        gcd(a, b) = 1
        gcd(a, d) = 1
        =>:
            gcd(a, b*d) = 1","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"""""""
Basics
""""""

forall x R, a R, b R:
    a + x = b
    =>:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    =>:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        =>:
            b - a > 0

    forall a R, b R:
        b > a
        =>:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        =>:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    <=>:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know @exist x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    <=>:
        x $in s
        $is_smallest_element_of(x, s)
    
know forall x Z, y Z => x * y $in Z, x + y $in Z, x - y $in Z

know forall x N, y N => x + y $in N, x * y $in N

know forall x N, y N => x + y $in N, x * y $in N


 """"""
Chapter 1
""""""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    let x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        =>:
            b / a $in Q

""""""
Chapter 2
""""""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist q Z st exist_largest_multiple_of(d Z, a Z):
    <=>:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    <=>:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        =>:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        =>:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        =>:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z: d != 0, a $is_divisible_by d, b $is_divisible_by d => gcd(a, b) $is_divisible_by d

""""""
Chapter 3
""""""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know:
    forall a Z, b Z:
        gcd(a, b) = 1
        <=>:
            $exist_relatively_prime(a, b)

# Corollary 3.1
know:
    forall a Z, b Z:
        dom:
            a != 0
            b != 0
        =>:
            a / gcd(a, b) $in Z
            b / gcd(a, b) $in Z
            gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know:
    forall a Z, b Z, d Z:
        a $is_divisible_by d
        b $is_divisible_by d
        =>:
            a + b $is_divisible_by d
            a - b $is_divisible_by d
            a * b $is_divisible_by d

# Theorem 3.2
know:
    forall a Z, b Z, d Z:
        gcd(a, d) = 1
        a*b $is_divisible_by d
        =>:
            b $is_divisible_by d

# Corollary 3.1
know:
    forall a Z, b Z, d Z:
        gcd(a, b) = 1
        gcd(a, d) = 1
        =>:
            gcd(a, b*d) = 1","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Syllogism example: 
# All humans are intelligent. Jordan is a human. 
# Therefore, Jordan is intelligent.


have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n N, m N","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R): x > 0 <=> x + 1 > 2","True"
"prop p(x R): x > 0 <=> x - 1 > 2","True"
"prop p(x R): x < 0 <=> x - 1 > 2","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R
a","False"
"have a N, b Q, c R
a N","False"
"have a N, b Q, c R","True"
"have a N, b Q, c R
a N
a>0","False"
"have a N, b Q, c R
a N
    a>0","False"
"have a N, b Q, c R
a N
    a > 0","False"
"have a N, b Q, c R
a N
    a > 0","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"have a R
know a = 1
a = 1","True"
"have a R
know a = 1
a = 1","True"
"have a R
know a = 1
a = 1","True"
"have a R
know a = 1
a = 1","True"
"have a R
know a = 1
a = 1","True"
"have a R
know a = 1
a = 1","True"
"know forall x N: x >= 47 => x >= 17
let x N: x = 47
x >= 17","True"
"prop larger_than_zero(x R):
    x > 0

$larger_than_zero(1)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"let a sequence(R), b finite_sequence(Z, 10)","True"
"1 > 0, forall x R => x $in R; 2 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"forall x R: x = 1 => x = 1","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let a N: a = 2, a = 3","True"
"1 $in N","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"or:
    1 = 1
    1 = 2","True"
"or:
    1 = 1
    1 = 2","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"have a N: a = 2, a = 3","False"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"square_root(4) $in R","False"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"square_root(4) $in R","False"
"let x R: x > 5
not x <= 5","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"prop p(x R, n N_pos)
let x R
know forall n N_pos: n >= 1, $p(x, n) => $p(x, n+1)
know $p(x, 1)

prove_by_induction($p(x, n), n, 1)","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"let x, y R:
    x = y

x = y
x + 1 = y + 1","True"
"=:
    1
    2 - 1
    1 * 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"forall x R:
    dom:
        x = 1
    =>:
        x != 2
    <=>:
        not x = 2","True"
"let x R
know:
    x > 0
    x != 2
    forall y R:
        y > 5
        =>:
            y > x","True"
"square_root(4) $in R","False"
"let x R: x > 5
not x <= 5","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R)","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"import ""Package""","False"
"import ""Package"" as p","False"
"""""""
multi-line comment
multi-line comment
multi-line comment
""""""
1+1=3","False"
"""""""
multi-line comment
multi-line comment
multi-line comment
""""""
1+1=2","True"
"""""""
multi-line comment
multi-line comment
multi-line comment
""""""
1+1!=2","False"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"claim:
    forall x R:
        x = 1
        =>:
            x > 0
    prove:
        1 > 0
        x > 0","True"
"let a, b N","True"
"""""""
multi-line comment
multi-line comment
multi-line comment
""""""","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Welcome to Litex Playground!

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact thaht literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Multivariate linear equation example: Solve the equation 2x + 3y = 10 and 4x + 5y = 14.
# 多元线性方程组：解方程 2x + 3y = 10 和 4x + 5y = 14。

let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
know a = 2
a = 1","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
know a = 2
a = 1
a = 2","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
know a = 2
a = 1
a = 2
1=2","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# The follow code will output unknown
1 = 2","False"
"# The follow code will output error
You can checkout any time you like but you can never leave.
What the F**K are you talking about?","False"
"# The follow code will output error
1","False"
"have a N, b Q, c R
let e N, f Q, g R","True"
"exist_prop x R st exist_number_larger_than(y R):
    x > y

exist 17 st $exist_number_larger_than(1)

$exist_number_larger_than(1)

have a st $exist_number_larger_than(1)

a $in R
a > 1","True"
"exist_prop x R st exist_number_larger_than(y R):
    x > y

exist 17 st $exist_number_larger_than(1)

$exist_number_larger_than(1)

have a st $exist_number_larger_than(1)

a $in R
a > 1","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"# The follow code will output unknown
1 = 2","False"
"# The follow code will output error
You can checkout any time you like but you can never leave.
What the F**K are you talking about?","False"
"# The follow code will output error
1","False"
"let a N: a = 2","True"
"let a N: a = 2, a = 3","True"
"let self_defined_empty_set set: forall x obj => not x $in self_defined_empty_set","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"forall x R: x = 1 => not x = 2 <=> x != 2","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"prop p(x R)","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"exist_prop x R st exist_number_larger_than(y R):
    x > y

exist 17 st $exist_number_larger_than(1)

$exist_number_larger_than(1)

have a st $exist_number_larger_than(1)

a $in R
a > 1","True"
"17 < 47 # verb: <, nouns: 17, 47
17 * 47 = 799 # verb: =, nouns: 17 * 47, 799
17 != 47 # verb: !=, nouns: 17, 47","True"
"have Term nonempty_set
have I, S, K Term
fn app(a Term, b Term) Term

have Value nonempty_set
have I0, K0, S0 Value
fn K1(a Term) Value
fn S1(a Term) Value
fn S2(a Term, b Term) Value

have List nonempty_set
have Nil List
fn Cons(x Term, xs List) List

have Machine nonempty_set
fn M0(x Term, stk List) Machine
fn M1(x Value, stk List) Machine
fn M2(x Value) Machine

fn step(m Machine) Machine
know:
    # M0 steps down
    forall x, y Term, l List:
        step(M0(app(x, y), l)) = M0(x, Cons(y, l))
    forall l List:
        step(M0(I, l)) = M1(I0, l)
        step(M0(K, l)) = M1(K0, l)
        step(M0(S, l)) = M1(S0, l)

    # M1 perform the combinators' actions
    step(M1(I0, Nil)) = M2(I0)
    step(M1(K0, Nil)) = M2(K0)
    step(M1(S0, Nil)) = M2(S0)
    forall x Term, l List:
        step(M1(I0, Cons(x, l))) = M0(x, l)
        step(M1(K0, Cons(x, l))) = M1(K1(x), l)
        step(M1(S0, Cons(x, l))) = M1(S1(x), l)
        step(M1(K0(x), Nil)) = M2(K0(x))
        step(M1(S1(x), Nil)) = M2(S1(x))
    forall x, y Term, l List:
        step(M1(K0(x), Cons(y, l))) = M0(x, l)
        step(M1(S1(x), Cons(y, l))) = M1(S2(x, y), l)
        step(M1(S2(x, y), Nil)) = M2(S2(x, y))
    forall x, y, z Term, l List:
        step(M1(S2(x, y), Cons(z, l))) = M0(app(app(x, z), app(y, z)), l)

    # M2 ends the evaluation
    forall x Value:
        step(M2(x)) = M2(x)

fn evalm(m Machine) Machine
know:
    forall x Term, l List:
        evalm(M0(x, l)) = evalm(step(M0(x, l)))
    forall x Value, l List:
        evalm(M1(x, l)) = evalm(step(M1(x, l)))
    forall x Value:
        evalm(M2(x)) = M2(x)

have program0 Term
know:
    program0 = app(I, K)

# now to execute the program ...
step(M0(program0, Nil)) = M0(I, Cons(K, Nil))
evalm(M0(program0, Nil)) = evalm(M0(I, Cons(K, Nil)))
# add more steps as necessary...","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n N, m N","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"have x R, y R, z R
(2x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","False"
"have x R, y R, z R
(2*x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"know forall x N: x >= 47 => x >= 17
let x N: x = 47
x >= 17","True"
"let x N: x = 47
x >= 17","True"
"let x N: x = 47
x >= 17","True"
"let x N: x = 47
x >= 17","True"
"let x N: x = 47
47 >= 17","True"
"let x N: x = 47
47 >= 17
x >= 17","True"
"square_root(4) $in R","False"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x","True"
"square_root(4) $in R","False"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x

square_root(4) $in R","True"
"fn square_root(x R) R: x >= 0 => square_root(x)^2 = x

square_root(-4) $in R","True"
"let x R: x > 5
not x <= 5","True"
"or:
    1 = 1
    1 = 2","True"
"or:
    1 = 3
    1 = 2","False"
"or:
    1 = 3
    1 = 1","True"
"=:
    1
    2 - 1
    1 * 1","True"
"1 + 1 = 2
4 / 2 = 2","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"let x R: x > 0
f(x) > 0","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"forall x R: x = 1 => not x = 2 <=> x != 2","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"let x R: x > 5
not x <= 5","True"
"=:
    1
    2 - 1
    1 * 1","True"
"=(1, 2 - 1, 1 * 1)","False"
"1 + 1 = 2
4 / 2 = 2","True"
"let a, b, c, d R: 
    a = c
    b = d
    a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6

claim:
    c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6
    prove:
        a + 2 * b + 3 * c + 2 = 3 * d + 4 * b + 5 * c + 6
        a + 2 * b + 3 * c + 2 = c + 2 * d + 3 * c + 2
        c + 2 * d + 3 * c + 2 = 3 * b + 4 * d + 5 * c + 6","True"
"prop p(x R)
prop q(x R)
know not $q(1)
know forall x R: $p(x) => $q(x)

claim:
    not $p(1)
    prove_by_contradiction:
        $p(1)
        $q(1)","True"
"# idők: hét napjai
let Days = {Mon, Tue, Wed, Thu, Fri, Sat, Sun}

# ételek típusa
let Food = {carb, protein, fiber, sugar, chicken}

# szabályok

# rost minden nap kell
forall d in Days:
    eat(d, fiber)

# szénhidrát hetente pontosan 1x
exists! d in Days:
    eat(d, carb)

# fehérje kétnaponta kell (pl. minden 2. napon)
forall d in Days:
    if even_index(d) then eat(d, protein)

# szerdán csirkét kell enni
eat(Wed, chicken)

# hétvégén megengedett a cukor
forall d in {Sat, Sun}:
    allowed(d, sugar)

# cukor szénhidrát
forall d in Days:
    eat(d, sugar) -> eat(d, carb)

# kérdés
? count_solutions({ eat(d, f) | d in Days, f in Food }, Rules)","False"
"# idők: hét napjai
let Days = {Mon, Tue, Wed, Thu, Fri, Sat, Sun}

# ételek típusa
let Food = {carb, protein, fiber, sugar, chicken}

# szabályok

# rost minden nap kell
forall d in Days: (d, fiber)

# szénhidrát hetente pontosan 1x
exists! d in Days: (d, carb)

# fehérje kétnaponta kell (pl. minden 2. napon)
forall d in Days:  even_index(d) then eat(d, protein)

# szerdán csirkét kell enni
eat(Wed, chicken)

# hétvégén megengedett a cukor
forall d in {Sat, Sun}:
    allowed(d, sugar)

# cukor szénhidrát
forall d in Days:
    eat(d, sugar) -> eat(d, carb)

# kérdés
? count_solutions({ eat(d, f) | d in Days, f in Food }, Rules)","False"
"# idők: hét napjai
let Days = {Mon, Tue, Wed, Thu, Fri, Sat, Sun}

# ételek típusa
let Food = {carb, protein, fiber, sugar, chicken}

# szabályok

# rost minden nap kell
forall d in Days: (d, fiber)

# szénhidrát hetente pontosan 1x
exists! d in Days: (d, carb)

# fehérje kétnaponta kell (pl. minden 2. napon)
forall d in Days:  even_index(d) then eat(d, protein)

# szerdán csirkét kell enni
eat(Wed, chicken)

# hétvégén megengedett a cukor
forall d in {Sat, Sun}: allowed(d, sugar)

# cukor szénhidrát
forall d in Days: eat(d, sugar) -> eat(d, carb)

# kérdés
? count_solutions({ eat(d, f) | d in Days, f in Food }, Rules)","False"
"# idők: hét napjai
have set Days = {Mon, Tue, Wed, Thu, Fri, Sat, Sun}

# ételek típusa
have set Food = {carb, protein, fiber, sugar, chicken}

# szabályok

# rost minden nap kell
forall d in Days: (d, fiber)

# szénhidrát hetente pontosan 1x
exists! d in Days: (d, carb)

# fehérje kétnaponta kell (pl. minden 2. napon)
forall d in Days:  even_index(d) then eat(d, protein)

# szerdán csirkét kell enni
eat(Wed, chicken)

# hétvégén megengedett a cukor
forall d in {Sat, Sun}: allowed(d, sugar)

# cukor szénhidrát
forall d in Days: eat(d, sugar) -> eat(d, carb)

# kérdés
? count_solutions({ eat(d, f) | d in Days, f in Food }, Rules)","False"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n N, m N","True"
"let n, m N:
    n > 0
    m > n","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"# definition of a group, and prove R and Z are groups
# 定义一个群，并证明 R 和 Z 是群

prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e
    forall x s:
        mul(x, e) = x
        mul(e, x) = x

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
intelligent(Jordan)","False"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"17 $in N
-47 + 17 $in Z
17.17 $in Q
forall x Q => x $in R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14

y = 6
x = -4","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"1 = 1 # true
let a R # Successfully declared a real number","True"
"# The follow code will output unknown
1 = 2","False"
"know 2 = 1
1 = 2","True"
"know 4 = 2
1 = 2","True"
"know 4 = 2
2 = 4 / 2
1 = 2 / 2
1 = 2","True"
"know 4 = 2
2 = 4 / 2
1 = 2 / 2
4 / 2 = 2 / 2
1 = 2","True"
"# The follow code will output error
You can checkout any time you like but you can never leave.
What the F**K are you talking about?","False"
"# The follow code will output error
1","False"
"have a N, b Q, c R
let e N, f Q, g R","True"
"have M nonempty_set","True"
"have M nonempty_set
have x M
know forall x M => x = 1
x = 1","True"
"have M nonempty_set
have x M
know forall x M => x = 1
x = 2","True"
"have M nonempty_set
have x M
know forall x M => x > 1
x = 2","True"
"have M nonempty_set
have x M
know forall x M => x > 1
x = 0.1","True"
"have M nonempty_set
have x M
know forall x M => x > 1
x = 0","True"
"let a N: a = 2","True"
"let a N: a = 2, a = 3","True"
"let self_defined_empty_set set: forall x obj => not x $in self_defined_empty_set","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"# Welcome to Litex Playground!
let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14","True"
"# Welcome to Litex Playground!
let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

2 * (2 * x + 3 * y) = 2 * 10 = 4 * x + 6 * y
y = (4 * x + 6 * y) - (4 * x + 5 * y) = 2 * 10 - 14 = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18 = -8
x = (2 * x) / 2 = -8 / 2 = -4","True"
"# Welcome to Litex Playground!
let x R, y R:
  2 * x + 3 * y = 10
  4 * x + 5 * y = 14

x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"prop g(x R)
prop s(x R)
prop q(x R)

know:
    forall x R: $g(x) => $s(x)
    forall x R: $s(x) => $q(x)
    not $q(17)

claim:
    not $g(17)
    prove_by_contradiction:
        $s(17)
        $q(17)","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"1 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R
let e N, f Q, g R","True"
"let a N: a = 2","True"
"let a N: a = 2, a = 3","True"
"let self_defined_empty_set set: forall x obj => not x $in self_defined_empty_set","True"
"exist_prop x R st exist_number_larger_than(y R):
    x > y

exist 17 st $exist_number_larger_than(1)

$exist_number_larger_than(1)

have a st $exist_number_larger_than(1)

a $in R
a > 1","True"
"let n N","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop p(x R, n N_pos)

let x R

know:
    forall n N_pos: n >= 2, $p(x, n) => $p(x, n+1)
    $p(x, 2)

prove_by_induction($p(x, n), n, 2)

forall n N_pos: n >= 2 => $p(x,n)","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have x R, y R, z R
(x + z * z) * (x + 7 * y) = x * x + 7 * y * x + z * x * z + y * (3 + 4) * z * z","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"prop p(x R):
    x > 0
    <=>:
        x + 1 > 1","True"
"prop p(x R) <=> x > 0","True"
"exist_prop x R st larger_than(y R):
    x > y","True"
"exist_prop x R st larger_than_positive(y R):
    y > 0
    <=>:
        x > y","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"forall x R: x = 1 => x = 1","True"
"forall x R: x = 1 => not x = 2 <=> x != 2","True"
"let x R
know x > 0, x != 2, forall y R: y > 5 => y > x","True"
"know @transitivity_of_less(a, b, c R):
    a < b
    b < c
    =>:
        a < c","True"
"prop transitivity_of_less(a, b, c R):
    a < b
    b < c

know:
    forall a, b, c R:
        $transitivity_of_less(a, b, c)
        =>:
            a < c
    forall a, b, c R:
        a < b
        b < c
        =>:
            a < c","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"have a N: a = 2, a = 3","False"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# definition of a group, and prove R and Z are groups
# 定义一个群，并证明 R 和 Z 是群

prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e
    forall x s:
        mul(x, e) = x
        mul(e, x) = x

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"claim:
	forall x, y R:
        x = -4
        y = 6
        =>:
            2 * x + 3 * y = 10
            4 * x + 5 * y = 14
    prove:
        =:
            10
            2 * -4 + 3 * 6
            2 * x + 3 * y
        =:
            14
            4 * -4 + 5 * 6
            4 * x + 5 * y","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"# definition of a group, and prove R and Z are groups
# 定义一个群，并证明 R 和 Z 是群

prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e
    forall x s:
        mul(x, e) = x
        mul(e, x) = x

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"1 + 1 = 2
0 * 4 + (9 - 3) * (2 - 1) = 6
2 != 3
3 > 0
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let n N
n $in N","True"
"# This file is translation of Lean4 code website https://leanprover-community.github.io/theories/naturals.html to Litex code.

4 + 1 + 1 = 6
4 - 3 =1
5 -6 != 0
1 != 0
4 * 7 = 28

forall m, n, p N:
    m + p = n + p
    =>:
        m + p - p = n + p - p
        # m = n

forall a, b, c N:
    a * (b + c) = a * b + a * c

# Basic facts like this will be implemented in standard library.
know @less_is_preserved_by_addition(m N, n N, p N):
    m + p < n + p
    =>:
        m < n

know:
    forall a, b, n N:
        n > 0
        a > b
        =>:
            a ^ n > b ^ n

forall a, b N:
    a + 1 < b + 1
    =>:
        $less_is_preserved_by_addition(a, b, 1)

forall a, b, n N:
    n > 0
    a > b
    =>:
        a ^ n > b ^ n","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"let n N, m N","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n N, m N","True"
"let n, m N:
    n > 0
    m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let x, y R:
    2*x + 3*y = 10
    4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"1 $in N","True"
"prop divisible_by(x, y N):
    y > 0
    <=>:
        x % y = 0

6 $divisible_by 3","True"
"prove:
    let x N_pos:
        x = 1
    or:
        x = 1
        x = 2

prove:
    let x R:
        not x < 0
    x >= 0

let x N:
    x = 0
x = 0","True"
"have set one_to_five := {1,2,3,4,5}","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let a N: a = 2, a = 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"prop p(x R)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!
x+y=5","False"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"""""""
algorithm.lix

Goal:
Formalize mathematical definition of algorithm from the book ""The Art of Computer Programming"" chapter 1.

Here is the definition of algorithm from the book:

So far our discussion of algorithms has been rather imprecise, and a mathematically oriented reader is justified in thinking that the preceding commentary makes a very shaky foundation on which to erect any theory about algorithms.
We therefore close this section with a brief indication of one method by which the concept of algorithm can be firmly grounded in terms of mathematical set theory. Let us formally define a computational method to be a quadruple (Q, I, S, f), in which Q is a set containing subsets I and S, and f is a function from Q into itself. Furthermore f should leave & point-wise fixed; that is, f(g) should equal a for al elements q of S. The four quantities Q, I, S, f are intended to represent respectively the states of the computation, the input, the output, and the computational rule. Each input x in the set I defines a computational sequence, x0, x1, x2,..., as follows:
x0 = x and x_{k+1} = f(x_k) for k≥0.
The computational sequence is said to terminate in k steps if k is the smallest
integer for which x_k is in S, and in this case it is said to produce the output x_k from x. (Note that if x_k is in S, so x_{k+1}, because x_{k+1} = x_k in such a case.) Some computational sequences may never terminate; an algorithm is a computational method that terminates in finitely many steps for all x in I.

""""""

# Definition of computational sequence
fn comp_seq(D set, f fn(D)D) fn(D, N)D:
    forall x D, n N:
        comp_seq(D, f)(x,n+1) = f(comp_seq(D, f)(x, n))
    comp_seq(D, f)(x, 0) = x

# Definition of end of computational sequence
exist_prop n N st exist_end_of_comp_seq(D set, x D, f fn(D,N)D):
    f(x, n) = f(x, n+1)

# Definition of algorithm
prop is_algorithm(D set, I set, f fn(D)D):
    forall x I: # i.e. I is subset of D
        x $in D
    <=>:
        forall x I:
            $exist_end_of_comp_seq(D, x, comp_seq(D, f))

# We prove $is_algorithm(R, R, f(x) = x)

fn f(x R)R:
    f(x) = x


claim:
    forall x R:
        $exist_end_of_comp_seq(R, x, comp_seq(R, f))
    prove:
        comp_seq(R, f) $in fn(R, N)R
        comp_seq(R, f)(x, 0) = x
        comp_seq(R, f)(x, 0 + 1) = f(comp_seq(R, f)(x, 0))
        comp_seq(R, f)(x, 0 + 1) = f(x)
        f(x) = x
        comp_seq(R, f)(x, 0 + 1) = x
        comp_seq(R, f)(x, 0) = comp_seq(R, f)(x, 1)
        exist 0 st $exist_end_of_comp_seq(R, x, comp_seq(R, f))

$is_algorithm(R, R, f)


""""""
Here is a Litex for Curious Lean Users4 code.
""""""

""""""
structure ComputationalMethod where
  Q : Type
  I : Set Q
  S : Set Q
  f : Q → Q
  f_fixed : ∀ q ∈ S, f q = q

namespace ComputationalMethod

def comp_sequence (cm : ComputationalMethod) (x : cm.Q) : ℕ → cm.Q
  | 0 => x
  | n + 1 => cm.f (comp_sequence x n)

def TerminatesIn (cm : ComputationalMethod) (x : cm.Q) (k : ℕ) : Prop :=
  comp_sequence cm x k ∈ cm.S ∧
  ∀ i < k, comp_sequence cm x i ∉ cm.S

def IsAlgorithm (cm : ComputationalMethod) : Prop :=
  ∀ x ∈ cm.I, ∃ k, TerminatesIn cm x k

end ComputationalMethod

open ComputationalMethod

def IdMethod : ComputationalMethod :=
{ Q := ℝ,
  I := Set.univ,
  S := Set.univ,
  f := id,
  f_fixed := by intros q h; rfl }

example : IsAlgorithm IdMethod :=
by
  intros x hx
  use 0
  unfold TerminatesIn comp_sequence
  constructor
  · simp
    exact Set.mem_univ _
  · 
    intros i hi
    exact False.elim (Nat.not_lt_zero _ hi)

""""""

""""""
Comments:
It only takes only 10 lines to formalize the definition of algorithm, which is marvelous.
""""""","True"
"claim:
    forall a, b, x R:
        x^2 + 2 * a * x + b = 0
        a^2 - b >= 0
        =>:
            or:
                x = -a + sqrt(a^2 - b)
                x = -a - sqrt(a^2 - b)
    prove:
        =:
            sqrt(a^2 - b) * sqrt(a^2 - b)
            sqrt(a^2 - b) ^ 2
            a^2 - b
        =:
            (x + a - sqrt(a^2 - b)) * (x + a + sqrt(a^2 - b))
            x ^ 2 + 2 * a * x + a^2 - sqrt(a^2 - b) ^ 2
            x ^ 2 + 2 * a * x + a^2 - (a^2 - b)
            x ^ 2 + 2 * a * x + b
            0
        $product_is_0_then_at_least_one_factor_is_0(x + a - sqrt(a^2 - b), x + a + sqrt(a^2 - b))
        
        prove_in_each_case:
            or:
                x + a + sqrt(a^2 - b) = 0
                x + a - sqrt(a^2 - b) = 0
            =>:
                or:
                	x = -a + sqrt(a^2 - b)
                    x = -a - sqrt(a^2 - b)
            prove:
                x + a + sqrt(a^2 - b) + (-a - sqrt(a^2 - b)) = 0 + (-a - sqrt(a^2 - b))
                x = 0 + (-a - sqrt(a^2 - b))
                x = -a - sqrt(a^2 - b) 
            prove:
                x + a - sqrt(a^2 - b) + (-a + sqrt(a^2 - b)) = 0 + (-a + sqrt(a^2 - b))
                x = 0 + (-a + sqrt(a^2 - b))
                x = -a + sqrt(a^2 - b)","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"""""""
Basics
""""""

forall x R, a R, b R:
    a + x = b
    =>:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    =>:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        =>:
            b - a > 0

    forall a R, b R:
        b > a
        =>:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        =>:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    <=>:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know @exist x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    <=>:
        x $in s
        $is_smallest_element_of(x, s)
    
know forall x Z, y Z => x * y $in Z, x + y $in Z, x - y $in Z

know forall x N, y N => x + y $in N, x * y $in N

know forall x N, y N => x + y $in N, x * y $in N


 """"""
Chapter 1
""""""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    let x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        =>:
            b / a $in Q

""""""
Chapter 2
""""""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist q Z st exist_largest_multiple_of(d Z, a Z):
    <=>:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know @exist m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    <=>:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        =>:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        =>:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        =>:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z: d != 0, a $is_divisible_by d, b $is_divisible_by d => gcd(a, b) $is_divisible_by d

""""""
Chapter 3
""""""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know:
    forall a Z, b Z:
        gcd(a, b) = 1
        <=>:
            $exist_relatively_prime(a, b)

# Corollary 3.1
know:
    forall a Z, b Z:
        dom:
            a != 0
            b != 0
        =>:
            a / gcd(a, b) $in Z
            b / gcd(a, b) $in Z
            gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know:
    forall a Z, b Z, d Z:
        a $is_divisible_by d
        b $is_divisible_by d
        =>:
            a + b $is_divisible_by d
            a - b $is_divisible_by d
            a * b $is_divisible_by d

# Theorem 3.2
know:
    forall a Z, b Z, d Z:
        gcd(a, d) = 1
        a*b $is_divisible_by d
        =>:
            b $is_divisible_by d

# Corollary 3.1
know:
    forall a Z, b Z, d Z:
        gcd(a, b) = 1
        gcd(a, d) = 1
        =>:
            gcd(a, b*d) = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let a N: a = 2, a = 3","True"
"exist_prop x R st larger_than(y R):
    x > y

exist 3 st $larger_than(2)","True"
"prop p(x R)

know $p(1)

$p(1)","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"have a N, b Q, c R","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have a R # It means a is in set R (R: The set of all real numbers)
know a = 1
a = 1","True"
"# Define three propositions
prop g(x Q)
prop s(x Q)
prop q(x Q)

know $g(1)
know forall x Q => $s(x)
know $q(1)
know forall x N: x > 7 => $g(x)
know forall x Q: x > 17 => $g(x)
$g(17.17)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"let x N, y N:
    x = y
    x > 0

y > 0","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"let n N, m N","True"
"let a N: a = 2, a = 3","True"
"prop p(x R)","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -5","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let n N, m N","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"prop p(x R, n N_pos)
let x R
know forall n N_pos: n >= 1, $p(x, n) => $p(x, n+1)
know $p(x, 1)

prove_by_induction($p(x, n), n, 1)","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# Welcome to Litex Playground!","True"
"# Welcome to Litex Playground!","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"let n N, m N","True"
"let n, m N: n > 0, m > n","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"let a N: a = 2, a = 3","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"have set one_to_five := {1,2,3,4,5}","True"
"let n N, m N","True"
"let x, y R: 2*x + 3*y = 10, 4*x + 5*y = 14","True"
"prop p(x R): x > 0 <=> x + 1 > 1","True"
"1 + 1 = 2
1 != 2
3 > 0","True"
"fn f(x R) R: x > 0 => f(x) > 0","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"prop is_group(s set, mul fn(s, s)s, inv fn(s)s, e s):
    forall x s, y s, z s:
        mul(mul(x, y), z) = mul(x, mul(y, z))
    forall x s:
        mul(x, inv(x)) = e
        mul(inv(x), x) = e

fn inverse(x R)R:
    inverse(x) + x = 0

forall x R:
    inverse(x) + x = 0
    x + inverse(x) = 0

forall x Z:
    x + inverse(x) = 0
    inverse(x) = -x
    -x $in Z
    inverse(x) $in Z

$is_group(R, +, inverse, 0)
$is_group(Z, +, inverse, 0)","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have a N, b Q, c R","True"
"exist_prop x R st larger_than(y R): 
    x > y
exist 2 st $larger_than(1)  # a $in R, a > 1
    
have a st $larger_than(1)  # a $in R, a > 1","True"
"have set one_to_five := {1,2,3,4,5}","True"
"prop P(x R)

have set s := x R:
    $P(x)","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"forall x R:
    x = 1
    =>:
        x = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Litex Code Example: Hilbert's Axioms of Geometry

# Below is the Hilbert axioms written in Litex code, along with a one-to-one correspondence with the definitions from Wikipedia. Although the following axioms are recognized as complete, some definitions and facts are implicitly omitted for simplicity. Here, I have made the necessary additions to ensure rigor and clarity.

# Read more about Hilbert's geometry axioms: https://en.wikipedia.org/wiki/Hilbert%27s_axioms .

# Hilbert's axiom system is constructed with six primitive notions: three primitive terms:
# point;
# line;
# plane+
# and three primitive relations:
# Betweenness, a ternary relation linking points;

# Betweenness, a ternary relation linking points;
# Lies on (Containment), three binary relations, one linking points and straight lines, one linking points and planes, and one linking straight lines and planes;
# Congruence, two binary relations, one linking line segments and one linking angles, each denoted by an infix ≅.
# Line segments, angles, and triangles may each be defined in terms of points and straight lines, using the relations of betweenness and containment. All points, straight lines, and planes in the following axioms are distinct unless otherwise stated.

let point set
let line set
let plane set

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. Incidence

# 1. For every two points A and B there exists a line a that contains them both. We write AB = a or BA = a. Instead of ""contains"", we may also employ other forms of expression; for example, we may say ""A lies upon a"", ""A is a point of a"", ""a goes through A and through B"", ""a joins A to B"", etc. If A lies upon a and at the same time upon another line b, we make use also of the expression: ""The lines a and b have the point A in common"", etc.

# 2. For every two points there exists no more than one line that contains them both; consequently, if AB = a and AC = a, where B ≠ C, then also BC = a.

fn line_of(a point, b point) line:
    a != b
    =>:
        $point_on_line(a, line_of(a, b))
        $point_on_line(b, line_of(a, b))
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            =>:
                l = line_of(a, b)

prove:
    # a line is determined by two points
    let a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)

    # line_of is commutative
    forall a point, b point:
        a != b
        =>:
            b != a
            $point_on_line(a, line_of(a, b))
            $point_on_line(b, line_of(a, b))
            $point_on_line(a, line_of(b, a))
            $point_on_line(b, line_of(b, a))
            line_of(a, b) = line_of(b, a)

# Tip: here prove mean ""open a local environment and the following content will not affect the outside"". It is a good way of doing small tests.

# 3.1. There exist at least two points on a line. 

exist_prop b point st exist_at_least_two_points_on_line(a point, l line):
    $point_on_line(a, l)
    <=>:
        $point_on_line(b, l)
        b != a

know forall a point, l line: $point_on_line(a, l) => $exist_at_least_two_points_on_line(a, l)

prove:
    let a point, l line:
        $point_on_line(a, l)

    $exist_at_least_two_points_on_line(a, l)

    have b st $exist_at_least_two_points_on_line(a, l)

    $point_on_line(b, l)

# 3.2 There exist at least three points that do not lie on the same line.

know @exist c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    <=>:
    
        not $point_on_line(c, line_of(a, b))

prove:
    let a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: It's a good and essential habit to name everything properly. I recommend you to use long names which contains all the information in the name. Do not worry about typing, because most IDEs will prompt or complete the rest of the name when you type the first few characters.

# Tip: know @, know @exist is a syntax sugar for making that prop(exist_prop) as an axiom.

# 4. For every three points A, B, C not situated on the same line there exists a plane α that contains all of them. For every plane there exists a point which lies on it. We write ABC = α. We employ also the expressions: ""A, B, C lie in α""; ""A, B, C are points of α"", etc.

# 5. For every three points A, B, C which do not lie in the same line, there exists no more than one plane that contains them all.

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    not $point_on_line(a, line_of(b, c))
    =>:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            =>:
                p = plain_of(a, b, c)

# Tip: axiom with uniqueness and existence can be written as a function.

# 6. If two points A, B of a line a lie in a plane α, then every point of a lies in α. In this case we say: ""The line a lies in the plane α"", etc.

know @two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        =>:
            $line_on_plane(l, p)

prove:
    let a point, b point, l line, p plane:
        a != b
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        $point_on_line(a, l)
        $point_on_line(b, l)
    $two_points_on_line_then_line_on_plane(a, b, l, p)
    $line_on_plane(l, p)

# 7. If two planes α, β have a point A in common, then they have at least a second point B in common.

know @exist b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    <=>:
        $point_on_plane(b, p)

prove:
    let a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. There exist at least four points not lying in a plane.

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()


prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. Order

# 1. If a point B lies between points A and C, B is also between C and A, and there exists a line containing the distinct points A, B, C.

prop between(left point, right point, middle point):
    dom:
        left != right

know forall left point, right point, middle point: left != right, $between(left, right, middle) => $between(right, left, middle)

know @exist l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    $between(a, b, c)
    <=>:
        a != c
        b != c
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

prove:
    let left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# 2. If A and C are two points, then there exists at least one point B on the line AC such that C lies between A and B.

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    <=>:
        $between(left, right, middle)

know forall a point, b point: a != b => $exist_point_right_to_given_two_points(a, b)

prove:
    let a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. Of any three points situated on a line, there is no more than one which lies between the other two.

know @no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    $point_on_line(a, line_of(b, c))
    =>:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    let a point, b point, c point:
        a != b
        a != c
        b != c
        $point_on_line(a, line_of(b, c))

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# 4. Pasch's Axiom: Let A, B, C be three points not lying in the same line and let a be a line lying in the plane ABC and not passing through any of the points A, B, C. Then, if the line a passes through a point of the segment AB, it will also pass through either a point of the segment BC or a point of the segment AC.

let finite_line set

fn finite_line_of(a point, b point) finite_line:
    a != b
    =>:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know @line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
        =>:
            or:
                $line_intersect_finite_line(a , c, l)
                $line_intersect_finite_line(b , c, l)

prove:
    let a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# TODO: There are still many axioms about relationship between finite_line and line not formulated. The user can add them easily at proper places.

# 3. Congruence

# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

# TODO: I am not sure if this formalization is exactly what the axiom means. May $point_on_line(b, l) be removed?
prop point_left_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

prop point_right_to_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_right_to_point_on_one_line(a, b, l)
                $point_left_to_point_on_one_line(a, b, l)

prop point_left_point_on_one_line(a point, b point, l line):
    dom:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

know:
    forall a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        =>:
            or:
                $point_left_to_point_on_one_line(a, b, l)
                $point_left_point_on_one_line(a, b, l)

know @exist a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
    <=>:
        a != b
        $point_left_to_point_on_one_line(a, b, l)
        $finite_line_equal(finite_line_of(a, b), l)

know @exist a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_to_point_on_one_line(b, a, l)
        $finite_line_equal(finite_line_of(a, b), l)
know:
    forall b point, l finite_line:
        $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b, l)

know:
    $commutative_prop(finite_line_equal)
    forall a point, b point:
        a != b
        =>:
            $finite_line_equal(finite_line_of(a, b), finite_line_of(b, a))

prove:
    let middle point, l finite_line
    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_to_point_on_one_line(left, middle, l)

    left != middle
    $finite_line_equal(finite_line_of(left, middle), l)


# TODO: The user can add relationships between $between, $point_left_to_point_on_one_line, $point_left_point_on_one_line, by himself. 

# Tip: There are 2 builtin keywords for commutative properties: $commutative_prop and $commutative_fn. The verifier will automatically prove a given commutatively if commutative property is true.

# 2. If a segment AB is congruent to the segment A′B′ and also to the segment A″B″, then the segment A′B′ is congruent to the segment A″B″; that is, if AB ≅ A′B′ and AB ≅ A″B″, then A′B′ ≅ A″B″.

know @finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    $finite_line_equal(l1, l2)
    $finite_line_equal(l2, l3)
    =>:
        $finite_line_equal(l1, l3)

prove:
    let l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. Let AB and BC be two segments of a line a which have no points in common aside from the point B, and, furthermore, let A′B′ and B′C′ be two segments of the same or of another line a′ having, likewise, no point other than B′ in common. Then, if AB ≅ A′B′ and BC ≅ B′C′, we have AC ≅ A′C′.

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    <=>:
        $point_on_line(a, line_of(b, c))

# This fact could be proved by other axioms, but I know it anyway.
know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        =>:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know @addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    =>:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)

    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. Let an angle ∠ (h,k) be given in the plane α and let a line a′ be given in a plane α′. Suppose also that, in the plane α′, a definite side of the straight line a′ be assigned. Denote by h′ a ray of the straight line a′ emanating from a point O′ of this line. Then in the plane α′ there is one and only one ray k′ such that the angle ∠ (h, k), or ∠ (k, h), is congruent to the angle ∠ (h′, k′) and at the same time all interior points of the angle ∠ (h′, k′) lie upon the given side of a′. We express this relation by means of the notation ∠ (h, k) ≅ ∠ (h′, k′).

# TODO: It seems to me that the proposition itself is not that clear. I formalize it in my own understanding.

let ray set
let half_plane set
let angle set

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, b point) ray:
    dom:
        a != b

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_right_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays_with_the_same_start_point(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)
    forall x point:
        $point_on_ray(x, r1)
        $point_on_ray(x, r2)
        =>:
            x = a

prop angle_equal(ang1 angle, ang2 angle)

prop half_plane_to_ray(a point, r ray, p half_plane):
    $point_on_ray(a, r)
    or:
        $half_plane_left_to_ray(a, r, p)
        $half_plane_right_to_ray(a, r, p)

know @exist r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    <=>:    
        $angle_equal(angle_of_two_rays_with_the_same_start_point(a, r1, r2), ang)

# TODO: Write some tests for this.

# 5. If the angle ∠ (h, k) is congruent to the angle ∠ (h′, k′) and to the angle ∠ (h″, k″), then the angle ∠ (h′, k′) is congruent to the angle ∠ (h″, k″); that is to say, if ∠ (h, k) ≅ ∠ (h′, k′) and ∠ (h, k) ≅ ∠ (h″, k″), then ∠ (h′, k′) ≅ ∠ (h″, k″).

know @angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    $angle_equal(ang1, ang2)
    $angle_equal(ang2, ang3)
    =>:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    let ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. If, in the two triangles ABC and A′B′C′ the congruences AB ≅ A′B′, AC ≅ A′C′, ∠BAC ≅ ∠B′A′C′ hold, then the congruence ∠ABC ≅ ∠A′B′C′ holds (and, by a change of notation, it follows that ∠ACB ≅ ∠A′C′B′ also holds).

let triangle set

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        =>:
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
            $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know @triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    a != b
    a != c
    b != c
    a2 != b2
    a2 != c2
    b2 != c2
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    =>:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    let a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. Parallel

# 1. Playfair's axiom: Let a be any line and A a point not on it. Then there is at most one line in the plane, determined by a and A, that passes through A and does not intersect a.

prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    <=>:
        not $point_on_line(a, l2)

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)

know @exist l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    <=>:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    let a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. Continuity

# 1. Axiom of Archimedes: If AB and CD are any segments then there exists a number n such that n segments CD constructed contiguously from A, along the ray from A through B, will pass beyond the point B.

fn finite_line_of_direction_and_length(a point, b point, n R) finite_line:
    dom:
        a != b
        n > 0

fn length_of_finite_line(l finite_line) R

prop in_the_same_direction(a point, b point, c point):
    dom:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_left_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_left_to_point_on_one_line(a, c, line_of(a, b))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        $in_the_same_direction(a, b, line_of(a, b))
        $point_right_to_point_on_one_line(a, b, line_of(a, b))
        =>:
            $point_right_to_point_on_one_line(a, c, line_of(a, b))
    
know @exist n R, c point st exist_finite_line_of_direction_and_length(a point, b point, l finite_line):
    n > 0
    $point_on_line(c, line_of(a, b))
    line_of(a, c) = n * length_of_finite_line(l)
    $in_the_same_direction(a, b, c)

# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# Completeness are actually dealing with real numbers. The keyword R is used to represent real numbers in Litex. Their properties will be implemented as part of the standard library in the future.

# All the axioms are formalized except the axiom of line completeness, which will be implemented as part of the standard library in the future.

# End of the Formalization.","True"
"# Syllogism example: All humans are intelligent. Jordan is a human. Therefore, Jordan is intelligent.
# 三段论：所有人类都是聪明的。乔丹是人类。因此，乔丹是聪明的。

have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
"# Chapter 2: Starting from the beginning: the natural numbers

# This file formalizes natural numbers axioms in chapter 2 of Analysis I, with explanations and examples.

# Axiom 2.1 0 is a natural number.

# The fact that literals are symbols for natural numbers within the set of natural numbers is built-in.
# N, Z, Q, R, C are built-in sets: the set of natural numbers, integers, rational numbers, real numbers, and complex numbers. Some of their properties are built-in, but Litex is flexible enough to allow the user to define and derive their own properties without any problem.

# factual expressions are typically written as $propName(objects). There are 3 handy exceptions: 1. builtin keywords like =, > are written as daily life math 2. If the proposition requires one and only one object, it can be written as ""object $propName"" 3. If the proposition requires two objects, it can be written as ""object1 $propName object2"".

0 $in N # This is a factual statement. Its output is true.

# Axiom 2.2 If n is a natural number, then the successor of n is also a natural number.
know forall x N => x + 1 $in N

# examples: the followings are true factual statements.
0 + 1 = 1
3 $in N
4 != 0
2 != 6

# Axiom 2.3 0 is not the successor of any natural number.
know forall x N => 0 != x + 1

# Axiom 2.4 If two natural numbers are equal, iff their successors are equal.
know:
    forall x N, y N:
        x != y
        <=>:
            x + 1 != y + 1

# Axiom 2.5 Principle of mathematical induction.
# prove_by_induction is a built-in function that takes a predicate and a natural number and returns true if the predicate is true for all natural numbers up to and including the natural number.
# The user actually can use ""prove_by_induction"" + ""there exists the smallest natural number"" to prove the principle of mathematical induction. In this case, he does not need to use the builtin keyword ""prove_by_induction"" to use ""prove_by_induction"" to prove correctness of a statement.

# define a random proposition
prop random_proposition(n N)

# know it satisfies the condition of the principle of mathematical induction
know:
    $random_proposition(1)
    forall n N_pos:
        n >= 1
        $random_proposition(n)
        =>:
            $random_proposition(n + 1)

# use ""prove_by_math_induction"" to prove random_proposition is true for all natural numbers larger than 0
prove_by_induction($random_proposition(n), n, 1)

# verify: $random_proposition(n) is true for all n N
forall n N_pos:
    n >= 1
    =>:
        $random_proposition(n)

# Assumption 2.6 There exists a number system N. Set N is built-in.

# Proposition 2.1.16 Recursive definition. The definition of recursion in this book is sort of confusing and informal because f(n)(a_{n}) is defined by a_{n}, but what is a_{n}? A sequence is not a set, because there might exists equal elements in a sequence. If a sequence is a function from N to N, then why do we need a function f(n) to define a function from N to N to make sure f(n)(a_{n}) = a_{n}? a_{n} itself is already that function which satisfies the condition a_{n} = a_{n}.

# Since addition and multiplication is so common in math, their basic properties are builtin in Litex. For example, Litex automatically checks equality of two polynomials by builtin expansion and combination.

# Addition of natural numbers.
forall x N, y N:
    (x + y) + 1 = (x + 1) + y

forall x N:
    0 + x = x

# Addition is commutative
forall x N, y N:
    x + y = y + x

# Addition is associative
forall x N, y N, z N:
    (x + y) + z = x + (y + z)

# Definition 2.2.1: a is positive if a != 0.
prop is_positive_natural_number(n N):
    n != 0

# Proposition 2.2.8: If a is positive, b is natural number, then a + b is positive.
know forall a N, b N: a != 0 => a + b != 0

# Corollary 2.2.9: If a and b are natural numbers such that a + b = 0, then a = 0 and b = 0.
know forall a N, b N: a + b = 0 => a = 0, b = 0

# Lemma 2.2.10: If a is positive, then there exists exactly one natural number b such that b + 1 = a.
know forall a N => (a - 1) + 1 = a

# Proposition 2.2.11: If n and m are natural numbers. We say n is greater than or equal to m, written n >= m, if n = m + k for some natural number k. We say n is strictly greater than m, written n > m, if n >= m and n != m.

# Definition 2.3.1 multiplication of natural numbers.
know forall x N => 0 * x = 0

forall x N, y N:
    (x + 1) * y = x * y + y

# Multiplication is commutative
forall x N, y N:
    x * y = y * x

# Multiplication is associative
forall x N, y N, z N:
    (x * y) * z = x * (y * z)

# Distributive law
forall x N, y N, z N:
    x * (y + z) = x * y + x * z

# 0 is the multiplicative identity
know forall x N => 0 * x = 0

# 1 is the multiplicative identity
know forall x N => 1 * x = x


# Chapter 3: Set theory

# This file formalizes set theory axioms in chapter 3 of Analysis I, with explanations and examples.

# Axiom 3.1 If A is a set, then A is an object. In particular, given two sets A and B, it is meaningful to ask whether A in B.
# ""in"" and ""set"" are built-in keywords. They behave in Litex just like how they behave in daily math (naive set theory).
# ""obj"" is a built-in keyword in Litex for declaring objects. Also, anything declared object (things that are not declared as prop or exist_prop) is an object (writes xxx $in obj). obj itself is not obj.
# The word ""object"" every now and then in Analysis I without any definition. It sort to reveals that explanations of basic elements in math are still missing in this book (or maybe in math world in general). The keyword ""obj"" in Litex is really something aligns with the word ""object"" means in math with Litex creators's understanding.

know forall s set => s $in obj

# Definition 3.1.4: Set A is equal to set B, written A = B, if and only if every element of A is an element of B and every element of B is an element of A.
know:
    forall A , B set:
        A = B
        <=>:
            forall x A:
                x $in B
            forall x B:
                x $in A

# Axiom 3.2: There exists a set which contains no elements
know @exist empty_set set st exist_empty_set():
    forall x obj:
        not $in(x, empty_set)

# Axiom 3.3: a is an object, then there exists a set A such that A contains and only contains a. If a and b are objects, then there exists a set A such that A contains and only contains a and b.
know @exist s set st exist_set_contains_and_only_contains_obj(a obj):
    forall x s:
        x = a
    a $in s

# Axiom 3.4: Definition of union of two sets.
fn union(A, B set) set:
    forall x A:
        x $in union(A, B)
    forall x B:
        x $in union(A, B)
    forall x union(A, B):
        or:
            x $in A
            x $in B

# Definition of subset.
prop is_subset_of(A, B set):
    forall x A:
        x $in B

# Axiom 3.5: Axiom of specification. If A is a set and P is a property, then there exists a set B such that B contains and only contains the elements of A that satisfy P.
# In Litex you can specify a set very flexibly.
prove:
    let s2 set # define a random set
    prop property_of_s2_items(x s2) # define a property of the elements of s2
    
    # TODO: Litex will provide the user a syntax sugar for defining a set by a property. Now we use the idea of ""if and only if"" to define a set by a property.
    let s set: # define s = {x in s2| property_of_s2_items(x) is true}
        s $is_subset_of s2
        forall x s:
            $property_of_s2_items(x)
        forall x s2:
            $property_of_s2_items(x)
            =>:
                x $in s
    
# TODO: Axiom 3.6 solves the problem of exist and only exist. But it is second-order logic. Since early versions of Litex does not support second-order logic for user, Litex will make it as built-in. The reason why early versions of Litex does not support second-order logic is that most math is based on first-order logic and the creator does not want to make it too complex for user. Second-order-logic is still a ""match and substitute"" logic (but, first order logic only match and substitute objects inside parameter list of a proposition, second order logic can match and substitute the name of that proposition.), but in order to keep the language simple, Litex needs another set of language features to make it independent from the main logic of ""first-order logic"" which is the default logic of Litex (the new system is similar to first-order logic, but you have to give a name to any universal fact with proposition as parameter because ordinary universal fact can not take proposition as parameter). Implementing and designing it is a matter of time, not something fundamental.
# Designing a proper syntax and semantics is tricky. Unlike another piece of logic, prove by math induction, which is a second-order logic, axiom of replacement is not that easy to implement. The inventor could implement it now, but he refuses to do so until he finds a way to make it more user-friendly. For the time being, the user can by default assume axiom of replacement is true and declare new sets whose existence is guaranteed by axiom of replacement. Again this is a matter of time, not something fundamental.

# Axiom 3.7: There exists a set N whose elements have properties defined in chapter 2.
# N is built-in in Litex. Most of the properties of N are also built-in. The user can also define his own properties of N easily.

# Axiom 3.8 is wrong because it leads to Russell's paradox.

# Axiom 3.9 (Regularity) If A is a non-empty set, then there is at least one element of A that is either not a set, or is disjoint from A
prop is_disjoint_from(A obj, B set):
    A $in set
    forall x A:
        not $in(x, B)

exist_prop x A st any_nonempty_set_has_item_that_is_not_a_set_or_is_disjoint_from_A(A set):
    or:
        not $in(x, set) # ""x is a set"" is written as $in(x, set)
        $is_disjoint_from(x, A)

# Axiom 3.10 (Power set axiom) Let X and Y be sets. Then there exists a set denoted by Y^{X} which contains all functions from X to Y



# Axiom 3.11 (Union axiom) Let X be a set. Then there exists a set denoted by union(X) which contains all elements of the elements of X.
fn union_of_set_in_sets(X set) set:
    forall x X:
        x $in set
    =>:
        x $in union_of_set_in_sets(X)

# Chapter 4: Integers and rationals

# This file formalizes integers and rationals axioms in chapter 4 of Analysis I, with explanations and examples.

# Keyword Z is a built-in set in Litex. Here are some basic built-in properties of Z.

Z $in set # Z is a set
1 $in Z
-1 $in Z
forall x N:
    x $in Z

# The following properties about Z are true for real numbers. Since integers are real numbers by builtin-rules automatically, the following facts are all true.

forall x, y, a, b Z: # this is syntax sugar for forall x Z, y Z, a Z, b Z:
    x - y + a - b = (x + a) - (y + b)

forall x, y Z:
    x - y = x + (-y)

forall x Z:
    x + (-x) = 0

forall x Z: # 0 is the additive identity
    x * 0 = 0

# associative law for addition
forall x, y, z Z:
    (x + y) + z = x + (y + z)

# associative law for multiplication
forall x, y, z Z:
    (x * y) * z = x * (y * z)

# distributive law
forall x Z, y Z, z Z:
    x * (y + z) = x * y + x * z

# 0 is the additive identity
forall x Z:
    x + 0 = x

# 1 is the multiplicative identity
forall x Z:
    x * 1 = x

know forall x N: x > 0 => not $in(-x, N)

exist_prop x N st given_int_is_reverse_of_nat(y Z):
    x + y = 0

# Lemma 4.1.5: Every integer is either a natural number or the negative of a natural number.
know forall x Z => or(x $in N, $given_int_is_reverse_of_nat(x))

# Use Lemma 4.1.5 to prove that -1 is not a natural number and there is a natural number t such that t + (-1) = 0

not $in(-1, N)
$given_int_is_reverse_of_nat(-1)
have t st $given_int_is_reverse_of_nat(-1)
t + (-1) = 0

# The rationals

know forall x2, y2 R: x2 != 0, y2 != 0 => x2 * y2 != 0

# proved by builtin rules for *, +, -, /
forall a2, b2, c2, d2 R:
    b2 != 0
    d2 != 0
    =>:
        b2 * d2 != 0
        a2 / b2 + c2 / d2 = (a2 * d2 + b2 * c2) / (b2 * d2)

forall a, b Q:
    a + b = b + a
    a * b = b * a

forall a, b, c Q:
    (a + b) + c = a + (b + c)
    (a * b) * c = a * (b * c)
    a * (b + c) = a * b + a * c
    (a + b) * c = a * c + b * c

forall a Q:
    a + 0 = 0 + a
    a = a + 0
    a + (-a) = 0
    a * 1 = 1 * a

forall a Q:
    a != 0
    =>:
        a / a = 1","True"
"let x R, y R:
    2 * x + 3 * y = 10
    4 * x + 5 * y = 14
2 * (2 * x + 3 * y) = 2 * 10
4* x + 6 * y = 2 * 10
(4*x + 6 * y) - (4*x + 5 * y) = 2 * 10 - 14
(4*x + 6 * y) - (4*x + 5 * y) = y
y  = 6
2 * x + 3 * 6 = 10
2 * x + 18 - 18 = 10 - 18
2 * x + 18 - 18 = -8
(2 * x) / 2 = -8 / 2
(2 * x) / 2 = x
x = -4","True"
"# prove sqrt(2) is irrational
# 证明 sqrt(2) 是无理数

fn logBase(x, y N) N:
    dom:
        x != 0

know forall x, y, z N => logBase(z, x^y) = y * logBase(z, x), logBase(z, x*y) = logBase(z, x) + logBase(z, y)

know forall x N: x != 0 => logBase(x, x) = 1

claim:
    not sqrt(2) $in Q
    prove_by_contradiction:
        sqrt(2) > 0
        have x, y st $rational_positive_number_representation_in_fraction(sqrt(2))
        
        x = sqrt(2) * y
        x ^ 2 = (sqrt(2) ^ 2) * (y ^ 2)
        sqrt(2) ^ 2 = 2
        x ^ 2 = 2 * (y ^ 2)

        logBase(2, x ^ 2) = logBase(2, 2 * (y ^ 2))     
        logBase(2, x ^ 2) = 2 * logBase(2, x)
        logBase(2, y ^ 2) = 2 * logBase(2, y)

        logBase(2, 2 * (y ^ 2)) = logBase(2, 2) + logBase(2, y ^ 2)
        logBase(2, 2) = 1
        logBase(2, 2 * (y ^ 2)) = 1 + logBase(2, y ^ 2)

        logBase(2, x ^ 2) = 1 + 2 * logBase(2, y)
        2 * logBase(2, x) = 1 + 2 * logBase(2, y)

        =:
            0
            (2 * logBase(2, x)) % 2            
            (1 + 2 * logBase(2, y)) % 2
            
        =:
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 2 * logBase(2, y)) % 2
            (1 % 2 + (2 * logBase(2, y)) % 2) % 2
            (1 + 0) % 2
            1
        0 = 1","True"
"have human nonempty_set, Jordan human
prop intelligent(x human)
know forall x human => $intelligent(x)
$intelligent(Jordan)","True"
